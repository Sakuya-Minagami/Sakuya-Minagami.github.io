---
title: 变量与作用域
---

# 变量声明
主要是谈var、let、const的事，简单记一下
[CSDN:JS中var、let、const详解](https://blog.csdn.net/ct5211314/article/details/120737706)
在ES6之前，我们都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以{}限定不了var声明变量的访问范围。

ES6 新增了let命令，用来声明局部变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效，而且有暂时性死区的约束。

let和var的区别体现在作用域上。var的作用域被规定为一个函数作用域，而let则被规定为块作用域，块作用域要比函数作用域小一些，但是如果两者既没在函数中，也没在块作用域中定义，那么两者都属于全局作用域。*但是let声明的全局变量不会挂在window，而是挂在script作用域*
简单应用：在for中，使用let仅块域有效，使用var对函数作用域乃至全局有效
```js
// for循环设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
//（他循环他的，你输出你的）
for(var i=0;i<5;i++){
    console.log(i);//0,1,2,3,4  全局   
    setTimeout(function(){
        console.log(i)//5,5,5,5,5  内部 
    },1000);//每次循环更改的是全局的i，所以最后输出的都是最后循环的i
 }
//传参解决
for(var i=0;i<5;i++){
   (function(k){
    setTimeout(function(){console.log(k)},1000)
    })(i);
}
 
 
for(let i=0;i<5;i++){
    console.log(i);//0,1,2,3,4  全局   
    setTimeout(function(){
        console.log(i)//0,1,2,3,4 内部 
    },1000);//当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量,JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。
 }
 // 由于let的块作用域特点，for循环每次任务访问到的i都是局部变量，这样拿到的i就是对的了
```
## 重声明
var可let不可。
const声明变量，并不是变量的值不得改动，而是指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。*变量冻结用Object.freeze方法*
## 变量提升
变量提升是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的行为。变量被提升后，会给变量设置默认值为 undefined。
*函数声明和条件执行的变量（无论条件）也会提升*
```js
fn()
var fn = function () {// 变量式声明函数
 console.log(1)  
}
// 输出结果：Uncaught TypeError: fn is not a function
foo()
function foo () {// 直接声明函数
 console.log(2)
}
// 输出结果：2
// ----------------
var name = "JavaScript"
function showName(){
  console.log(name);
  if(0){
   var name = "CSS" // 不成立也会提升，然后赋值undefined
  }
}
showName()// 输出undefined
```
let和const不存在变量提升，存在死区，声明前使用该类变量会报错，称为暂时性死区
# 私有变量
js秉承着一切皆对象的原则，尽管es6引入了类的概念，本质上依然没有私有和共有的区分，没有修饰符用于定义私有变量
[JavaScript用weakmap创建对象私有属性](http://www.taodudu.cc/news/show-629179.html)（不知道为什么链接炸了）
不过现在es7已经有哈希用法了，直接将变量以#开头命名，在别处上下文访问该变量直接报错
## 实现
### weakmap
即以对象作为键，变量作为值保存在weakmap中，仅能通过``map.get(obj)``访问
*相当于开了个仓库，每个对象配了把钥匙开锁*
```js
const privateAttribute = new WeakMap()

class MyClass {
  constructor() {
    privateAttribute.set(this, '私有属性')
  }

  getPrivateAttribute() {
    return privateAttribute.get(this)
  }
}

let myObj = new MyClass()
console.log(myObj.getPrivateAttribute()) // 输出：“私有属性”
console.log(myObj[privateAttribute]) // 输出：undefined
```
### Symbol
同样的道理，用symbol同样实现，利用的是symbol值永远唯一，哪怕标识符相同
```js
const widthSymbol = Symbol('width');
const heightSymbol = Symbol('height');
class Shape {  
	constructor(width, height) {
	    this[widthSymbol] = width;
	    this[heightSymbol] = height;
	}  
	get area() {    
		return this[widthSymbol] * this[heightSymbol];
	}
}
	const square = new Shape(10, 10);
	console.log(square.area);         // 100
	console.log(square.widthSymbol);  // undefined
	console.log(square[widthSymbol]); // 10
```
### 闭包
```js
const Person = (function() {
	let name;
	function Person(n) {
		name = n;
	}
	Person.prototype.getName = function() {
		return name;
	};
	return Person;
}());
let person1 = new Person('小明');
```
问题在于这里闭包只实现了私有性，却无法保证变量间的独立性，不能给每个实例都独立一个私有变量
```js
let person1 = new Person('小明');
let person2 = new Person('大明');
console.log(person1.getName()); // 大明
```

# 作用域
[JS 的 9 种作用域，你能说出几种](https://cloud.tencent.com/developer/article/2212250)
一般来说简单区分只有全局作用域和局部作用域，es6以后出现了let和const，产生了块作用域
# 上下文
[JavaScript-作用域、块级作用域、上下文、执行上下文、作用域链](https://cloud.tencent.com/developer/article/1402536)
上下文和作用域是不同的概念。
每个函数调用都有与之相关的作用域和上下文。从根本上说，作用域是基于函数，而上下文是基于对象。
作用域是和每次函数调用时变量的访问有关，并且每次调用都是独立的。
上下文总是关键字 this 的值，是调用当前可执行代码的对象的引用。
[从 ECMAScript 6 角度谈谈执行上下文](https://cloud.tencent.com/developer/article/2373449?areaId=106001)
[JS 到底是在干嘛：一文搞懂JS 执行上下文](https://cloud.tencent.com/developer/article/2335963?areaId=106001)

当通过HTML读取时，如果浏览器遇到要通过``<script>``标签或包含类似onClick的JS代码的属性运行的JS代码，它会将其发送给它的JS引擎。
然后，浏览器的JS引擎创建一个特殊的环境来处理这段JS代码的转换和执行。这个环境称为执行上下文。
执行上下文包含当前正在运行的代码，以及帮助其执行的所有内容。
在执行上下文运行时，解析器解析存储在内存中的特定的代码、变量和函数，生成可执行的字节码，并执行代码。
JavaScript 中有两种执行上下文:

全局执行上下文(GEC)
函数执行上下文(FEC)
**接下来的部分，就是JS如何运转的过程了，具体转到js原理篇**

保存一道经典题目
[js执行上下文与作用域](https://www.bilibili.com/video/BV1wD4y1D7Pp)
```js
function foo() {
    console.log(a); // 2
}

function bar() {
    var a = 3;
    foo();
}

var a = 2;
bar();
```
简单的解释是：函数上下文在创建时被确立而不是调用时，所以foo只能访问到全局的变量a而不是bar内的a