---
title: 经典面试题
---
# 前端跨域问题
## 同源策略
同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收
当浏览器分别打开两个网页时，会检查是否同源，只有同源的脚本才允许执行
## 常用方案
### CORS
跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现CORS的关键就是服务器，只要服务器实现了CORS请求，就可以跨源通信了。
```js
var http = require('http');
var server = http.createServer();
var qs = require('querystring');
 
server.on('request', function(req, res) {
        // 跨域后台设置
        res.writeHead(200, {
            'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
            'Access-Control-Allow-Origin': 'http://www.demo1.com',    // 允许访问的域（协议+域名+端口），可以设置为*表示不限制
            'Set-Cookie': 'l=a123456;Path=/;Domain=www.demo2.com;HttpOnly'   // HttpOnly:脚本无法读取cookie
        });
        res.end();
    });
});
 
server.listen('8080');
console.log('Server is running at port 8080...');
```
### JSONP
通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。
```js
<script>
    var script = document.createElement('script');
    script.type = 'text/javascript';
 
    // 传参并指定回调执行函数为onBack
    script.src = 'http://www.demo2.com:8080/login?user=admin&callback=onBack';
    document.head.appendChild(script);
 
    // 回调执行函数
    function onBack(res) {
        alert(JSON.stringify(res));
    }
 </script>

// vue
this.$http.jsonp('http://www.demo2.com:8080/login', {
    params: {},
    jsonp: 'onBack'
}).then((res) => {
    console.log(res); 
})

// node.js
server.on('request', function(req, res) {
    var params = qs.parse(req.url.split('?')[1]);
    var fn = params.callback;
 
    // jsonp返回设置
    res.writeHead(200, { 'Content-Type': 'text/javascript' });
    res.write(fn + '(' + JSON.stringify(params) + ')');
 
    res.end();
});
```
### nginx反向代理
跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。

实现思路：通过nginx配置一个代理服务器（域名与demo1相同，端口不同）做跳板机，反向代理访问demo2接口，并且可以顺便修改cookie中demo信息，方便当前域cookie写入，实现跨域登录。
采用同样的思路可以用node实现
```js
var express = require('express');
var proxy = require('http-proxy-middleware');
var app = express();
 
app.use('/', proxy({
    // 代理跨域目标接口
    target: 'http://www.demo2.com:8080',
    changeOrigin: true,
 
    // 修改响应头信息，实现跨域并允许带cookie
    onProxyRes: function(proxyRes, req, res) {
        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');
        res.header('Access-Control-Allow-Credentials', 'true');
    },
 
    // 修改响应信息中的cookie域名
    cookieDomainRewrite: 'www.demo1.com'  // 可以为false，表示不修改
}));
 
app.listen(3000);
console.log('Proxy server is listen at port 3000...');
```
# 数组扁平化
## 递归
传统办法
```js
function flatten(arr) {
  let result = [];
  // 此处也可使用for...of遍历
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
    // 是数组就等返回值
      result = result.concat(flatten(arr[i]));
    } else {
    // 不是数组直接拼接
      result.push(arr[i]);
    }
  }
  return result;
}
```
## 类型转换
利用es6走点捷径
```js
function flatten(arr) {
  return arr.toString().split(',').map((item) => Number(item));
}
```
toString方法可以直接扁平化，不过需要字符串重新转数组
也可以用JSON.stringfy，不同的是会保留中括号，要匹配去掉
```js
function flatten(arr) {
  const res = JSON.stringfy(arr).replace(/$|$/g,"");
  return JSON.parse("[" + res + "]");
}
```
## 调api
直接使用ES6提供的flat方法实现扁平化。falt()方法会按照指定的深度递归遍历数组，``arr.flat([depth])``，参数depth不填时默认值为1，depth为Infinity表示展开任意深度的嵌套数组。
```js
function flatten(arr) {
  return arr.flat(Infinity);
}
```
## 构造栈
其实跟递归很像，不过更节约资源，只在一个栈中做操作
```js
function flatten(arr) {
  const stack = [...arr];
  const res = [];
  while (stack.length) {
    // 出栈 从 stack 中取出一个元素
    const next = stack.pop();
    if (Array.isArray(next)) {
      // 展开一层重新入栈
      stack.push(...next);
    } else {
      res.unshift(next);
    }
  }
  return res;
}
```
# 数组去重
衔接扁平化
## 双指针
```js
function unique(arr){
	for(let i=0;i<arr.length;i++){
		for(let j=i+1;j<arr.length;i++){
			if(arr[i] === arr[j]){
				arr.splice(j,1);
				j--;
			}
		}
	}
	return arr
}
```
## 构造新数组includes()
```js
function unique(arr){
	const res = [];
	arr.forEach((item) => {
		if(!res.includes(item)){
			res.push(item);
		}
	})
	return res
}
```
## 利用set()
```js
function unique(arr){
	return [...new Set(arr)]
}
```
