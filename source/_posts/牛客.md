---
title: 牛客
---
为什么开了力扣还要开一篇牛客呢，因为牛客的在线编辑器太辣鸡了，需要自己处理输入输出
首先读取输入需要调用函数，还必须使用await
其次输出还要用``console.log()``，占用调试地方
然而当输入只有一个的时候还好，当输入多起来就是地狱
我需要多次调用``readline()``并依次赋值
我还不能预先处理``await readline().split(" ")``，必须要先赋值再处理
读取到的一行数据用空格隔开，所以我还要处理空格再转类型
太dinner了，不会给个数组？
# 简单题
## 合并表记录
一个解构数据的方案``let [k, v] = line.split(" ");``
```js
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
    while ((line = await readline())) {
        let obj = {};
        for (let i = 0; i < parseInt(line); i++) {
            const line = await readline();
            let [k, v] = line.split(" ");
            if (obj[k]) {
                obj[k] += parseInt(v);
            } else {
                obj[k] = parseInt(v);
            }
        }
        for (let j in obj) {
            console.log(j + " " + obj[j]);
        }
    }
})();
```
## 求int型正整数在内存中储存时1的个数
主要是进制转换，``parseInt(line,10)``转十进制怎么也想不到
```js
line = await readline();
var s = parseInt(line,10).toString(2)+"";
var count = 0;
for(let i=0;i<s.length;i++){
    if(s[i] === "1") count++;
}
console.log(count)
```
## 单词倒排
split的新用法
```js
s = await readline();
s = s.split(/[^A-Za-z]/).reverse().join(" ");
console.log(s)
```
## 统计字符
正则匹配的使用思路
```js
    var line = await readline();
    var arr = line.split("");
    var count = [0,0,0,0];
    arr.forEach((item) => {
        if(/[a-zA-Z]/.test(item)){
            count[0]++;
        }else if(/ /.test(item)){
            count[1]++;
        }else if(/[0-9]/.test(item)){
            count[2]++;
        }else {
            count[3]++;
        }
    })
    count.forEach((item) => {
        console.log(item)
    })
```
## 整数与ip地址转换
要对字符串操作函数很熟练
```js
    const toNum = (ip) =>
        parseInt(
            ip
                .split(".")
                .map((e) => parseInt(e, 10).toString(2).padStart(8, 0))
                .join(""),
            2
        );
    const toIP = (num) => {
        const str = parseInt(num, 10).toString(2).padStart(32, 0);
        let res = [];
        for (let i = 0; i < str.length; i = i + 8) {
            res.push(parseInt(str.slice(i, i + 8), 2).toString(10));
        }
        return res.join(".");
    };
    console.log(toNum(readline()));
    console.log(toIP(readline()));
```
放一个自己重置版
```js
    line = await readline();
    arr = line.split(".");
    ip2Num = "";// 准备拼成二进制字符串
    arr.forEach((item) => {
        ip2Num += parseInt(item,10).toString(2).padStart(8,0);
    });
    console.log(parseInt(ip2Num,2));

    line = await readline();
    num = parseInt(line,10).toString(2).padStart(32,0);
    num2ip = [];// 准备分成四份用.连接
    for(let i=0;i<32;i+=8){
        num2ip.push(parseInt(num.slice(i,i+8),2));
    }
    console.log(num2ip.join("."))
```
## 蛇形矩阵
最好还是按题目思路来，解数列还是有风险的
这里主要是摸清怎么把数填进去
```js
    var line = await readline();
    const num = parseInt(line);
    const arr = [];
    for (let i = 1; i <= num; i++) {
        arr.push([]);
    }
    let a = 1;
    for (let i = 0; i < num; i++) {
        for (let j = i; j >= 0; j--) {
            arr[j].push(a);
            ++a;
        }
    }
    arr.forEach((e, i) => {
        console.log(e.join(" "));
    });
```
# 中等题

## 密码截取
主要是明确思路：寻找最长回文串，关键是从中心开始向两侧寻找回文长度
```js
    var str = await readline();
    function findStr(s,left,right){
        while(left >=0 && right <= s.length && s[left] === s[right]){
            left--;
            right++;
        }
        return right - left -1
    }
    var arr = [];
    for(let i=0;i<str.length;i++){
        arr.push(Math.max(findStr(str,i,i),findStr(str,i,i+1)))
    }
    console.log(Math.max(...arr))
```
## 字符串加密
主要是用set构造映射结果字符串很重要
```js
    var key = await readline();
    var msg = await readline();
    var table = "abcdefghijklmnopqrstuvwxyz";
    var tableArr = [...new Set(key+table)];
    var map = new Map();
    for(let i=0;i<table.length;i++){
        map.set(table[i],tableArr[i]);
    }
    var ans = "";
    for(let j=0;j<msg.length;j++){
        ans += map.get(msg[j]);
    }
    console.log(ans)
```
## 称砝码
思路就是从前面已经称完的砝码开始遍历，用set装可能的重量，给新的砝码拿进去对照
重点是双层循环来遍历可能性

```js
    line = await readline();
    const n = parseInt(line);// 表示砝码个数

    line = await readline();
    let m = [];// 表示各砝码质量
    line.split(" ").forEach((item) => {
        m.push(parseInt(item));
    })

    line = await readline();
    let num = [];// 表示各砝码数
    line.split(" ").forEach((item) => {
        num.push(parseInt(item));
    })
// 总算读完数据了
    let ans = new Set([0]);
    for(let i=0;i<n;i++){
        let cur = [...ans];
        for(let j=1;j<=num[i];j++){
            cur.forEach(item => {
                ans.add(item + j * m[i]);
            })
        }
    }
    console.log(ans.size);
```
### 别的思路
其实核心问题就是一个线性方程问题
``a1x1 + a2x2 + a3x3 ... = b``即``AX = B``
``[a1,a2...]``是砝码数，``[x1,x2...]``是砝码质量
A即砝码数集合，B即解集合
A的每一个行向量都是可行的砝码数组合
B去重后大小即答案
问题在于构造A，需要遍历所有可能，n个砝码即n维，需要循环n次
这个n维解空间中``(a1,a2,a3,...,an)``表示各砝码取的个数
要依次生成
``[0,0],[0,1],[0,2],[1,0],[1,1],[1,2]``
这样形式的行向量组
另外，js原生没有矩阵运算函数，自己写大概会不合题意吧。。

## 迷宫问题
很乱，都先放着，只有最后一个是可行的
```js
    line = await readline();
    [n,m] = line.split(" ");
    n = parseInt(n);
    m = parseInt(m);
    let arr = [];
    for(let i=0;i<n;i++){
        line = await readline();
        arr.push(line.split(" "));
    }
    let v = [...Array(n[0])].map(() => Array(n[1]).fill(0));

    function findNext(i,j,road){
        road.push([i,j]);
        arr[i][j] = "1";
        if(i === n-1 && j === n-1){
            for(let i of road){
                console.log(`(${i[0]},${i[1]})`);
            }
        }
        if(j < n-1 && arr[i][j+1] === "0" && v[i][j + 1] == 0){
            v[i][j + 1] = 1; 
            findNext(i,j+1,road.slice());
            v[i][j + 1] = 0
        };// 右
        if(i < m-1 && arr[i+1][j] === "0") findNext(i+1,j,road.slice());// 下
        if(j >= 1 && arr[i][j-1] === "0") findNext(i,j-1,road.slice());// 左
        if(i >= 1 && arr[i-1][j] === "0") findNext(i-1,j,road.slice());// 上
    }
    findNext(0,0,[]);
```
```js
 let n = readline().split(" ").map(Number), maze = []; //读数据 
 while ((line = readline())) maze.push(line.split(" ").map(Number)); 
 let v = [...Array(n[0])].map(() => Array(n[1]).fill(0)); 
 function find(i, j, road) { 
	 road.push([i, j]); //先推入0,0 
	 maze[i][j] = 1; 
	 if (i == n[0] - 1 && j == n[1] - 1) { 
		 for (let i of road) print(`(${i[0]},${i[1]})`); } 
if (j + 1 < n[1] && maze[i][j + 1] == 0 && v[i][j + 1] == 0) { 
	v[i][j + 1] = 1; 
	find(i, j + 1, road); v[i][j + 1] = 0; 
	road.pop(); 
} //右 
if (i + 1 < n[0] && maze[i + 1][j] == 0 && v[i + 1][j] == 0) { v[i + 1][j] = 1; find(i + 1, j, road); v[i + 1][j] = 0; road.pop(); } //下 if (j - 1 >= 0 && maze[i][j - 1] == 0 && v[i][j - 1] == 0) { v[i][j - 1] = 1; find(i, j - 1, road); v[i][j - 1] = 0; road.pop(); } //左 if (i - 1 >= 0 && maze[i - 1][j] == 0 && v[i - 1][j] == 0) { v[i - 1][j] = 1; find(i - 1, j, road); v[i - 1][j] = 0; road.pop(); } //上 } find(0, 0, []);
```
```js
line = await readline();
const [n ,m] = line.split(' ').map(Number)
const matrix = []
while(line = await readline()) {
    matrix.push(line.split(' ').map(Number))
}
// 定义四个方向
const dirs = [[0, 1], [0, -1], [-1, 0], [1, 0]]

function findPath(matrix) {
    const dfs = (matrix, x, y) => {
        let pathList = []
        // 查找到目标点开始回溯
        if (x === n - 1 && y === m - 1) {
            return [[x, y]]
        }
      	// 每次查找后将值置为1 
        matrix[x][y] = 1
        for(const [dx, dy] of dirs) {
            const row = x + dx
            const col = y + dy
            // 索引越界跳过
            if(row < 0 || row >= n || col < 0 || col >= m) continue
          	// 值为墙跳过
            if (matrix[row][col] === 1) continue
            pathList = dfs(matrix, row, col)
          	// 长度不为0表示已经查找到终点，将终点的上一个回溯点入队
            if (pathList.length !== 0) {
                pathList.unshift([x, y])
                return pathList
            }
        }
        return pathList
    }
    return dfs(matrix, 0, 0)
    
}

const pathList = findPath(matrix)
pathList.forEach(([x,y]) => {
    console.log(`(${x},${y})`)
})

```
## 四则运算
中序表达式的计算，一般转后序再计算

## 计算字符串的编辑距离
经典动态规划问题
数学模型：
注意到字符串编辑距离可以由更小的字符串计算，因此存在唯一的递推关系
``f(a,b)=c``，二元函数可以用表格表示
再采用递推式即可
```js
    const A = await readline();
    const B = await readline();
    let arr = [];
    // 构造矩阵
    for(let i=0;i<=A.length;++i){
        arr[i] = Array.from(","+B).map((item,index) => i === 0 ? index:0);
        arr[i][0] = i;// 边界先填
    }
    for(let i=1;i<arr.length;i++){
        for(let j=1;j<arr[i].length;j++){
            if(A[i-1] === B[j-1]){
                arr[i][j] = arr[i-1][j-1];
            }else {
                arr[i][j] = Math.min(
                    arr[i-1][j-1] + 1,
                    arr[i-1][j] + 1,
                    arr[i][j-1] + 1,
                )
            }
        }
    }
    console.log(arr[arr.length-1][arr[0].length-1])
```
## 放苹果
也是动态规划问题，注意写递归函数会爆空间
思路即方法数为存在空盘子的放法加上每个盘子都放至少1个苹果的放法（后者等价于先给每个盘子放苹果，然后再重新考虑空盘子）
递推式为``f(m,n)=``
``f(m-n,n)+f(m,n-1),m>n``
``f(m,m),m<=n``
这里把后者合并到``f(m,n-1)``里了，也可以，等价的
另外创建矩阵的格式要记好
``var arr = new Array(m+1).fill(0).map(() => new Array(n+1).fill(0));``
```js
    line = await readline();
    line = line.split(" ");
    const m = parseInt(line[0]);
    const n = parseInt(line[1]);
    // 创建矩阵
    var arr = new Array(m+1).fill(0).map(() => new Array(n+1).fill(0));
    // 填充边界
    for(let i=0;i<=m;i++){
        arr[i][0] = 1;
        arr[i][1] = 1;
    }
    for(let j=1;j<=n;j++){
        arr[0][j] = 1;
        arr[1][j] = 1;
    }
    // 递推填充
    for(let i=2;i<=m;i++){
        for(let j=2;j<=n;j++){
            arr[i][j] = arr[i][j-1] + (i >= j ? arr[i-j][j] : 0);
        }
    }
    console.log(arr[m][n]);
```
## DNA序列
其实很简单，记一下一些细节
自己写的复杂很多
```js
    var str = await readline();
    line = await readline();
    const n = parseInt(line);
    var len = [];
    var temp = 0;
    for(let i=0;i<str.length-n+1;i++){
        for(let j=0;j<n;j++){
            if(str[i+j] === "C" || str[i+j] === "G"){
                temp++;
            }
        }
        len.push(temp/n);
        temp = 0;
    }
    console.log(str.substr(len.indexOf(Math.max(...len)),n))
```
简洁版
主要是使用filter可以节约一层循环
```js
let str = readline()
let num = readline()
let result = ''
let max = 0
for(let i = 0; i <= (str.length - num); i++) {
    let s = str.substr(i, num).split('').filter(item => item == 'C' || item == 'G').length
    if (s > max) {
        result = str.substr(i, num)
        max = s
    }
}
console.log(result)

```
## 矩阵乘法
不难，也许以后用得上
```js
    const m = parseInt(await readline());
    const p = parseInt(await readline());
    const n = parseInt(await readline());
    var A = new Array(m).fill(0).map(() => new Array(p).fill(0));
    var B = new Array(p).fill(0).map(() => new Array(n).fill(0));
    // console.log(A,B)
    for(let i=0;i<m;i++){
        line = await readline();
        line = line.split(" ").map(item => parseInt(item));
        A[i] = [...line];
    }
    for(let i=0;i<p;i++){
        line = await readline();
        line = line.split(" ").map(item => parseInt(item));
        B[i] = [...line];
    }
    var C = new Array(m).fill(0).map(() => new Array(n).fill(0));
    for(let i=0;i<m;i++){
        for(let j=0;j<n;j++){
            var sum = 0;
            for(let k=0;k<p;k++){
                sum += A[i][k]*B[k][j];
            }
            C[i][j] = sum;
        }
    }
    C.forEach(item => {
        console.log(item.join(" "))
    })
```
## 矩阵乘法计算量估算
想了半天，没想出来用栈
理一下思路：
必须要找到前面依次给的矩阵，和后面字符串找到的矩阵做对应
以及在反复执行的过程中，要保存上一次的矩阵，并要确认接下来的矩阵运算左乘还是右乘
这种解法对第一个问题采用ascll码``rule.charCodeAt(i) -65``就可以访问到字母对应的下标
第二个问题解决采用栈，主要确定三个访问逻辑：
读到左括号，无事发生继续读
读到右括号，先出栈进行运算（题目会给所有运算带括号， 不需要清空栈）
读到字母，字母入栈
```js
function deal(arr, rule) {
    // console.log(arr, rule)
    var result = []; // 模拟栈结构
    var count = 0; // 计算次数
    for(var i = 0; i < rule.length; i++) {
       // console.log(rule.charCodeAt(i))
        if(rule[i] == '('){
             
        } else if(rule[i] == ')'){
            // 遇到后括号，出栈计算将结果重新入栈
                var second = result.pop();
                var first = result.pop();
                count += first[0] * second[0] * second[1];
                result.push([first[0], second[1]]);
        } else {
            // 通过字母的ASCLL码 判断对应矩阵的顺序
            result.push(arr[rule.charCodeAt(i) -65]);
        }
    }
    console.log(count);
}
```
代码太简洁了，羡慕
## 字符串通配符
```js
let line1 = readline();
let line2 = readline();
function checkWildcard(str1, str2) {
    //构建新string，将"?","*"转换成正则表达式中相应的表达，注意不需要大小写，所以都转换成小写（大写亦可）；
    let newStr1 = str1.replace(/\?/g,'[A-Za-z0-9]' ).replace(/\*/g, '[A-Za-z0-9]{0,}').toLowerCase();
    let newStr2 = str2.toLowerCase();
    let output = false;
    //由示例5可知，需完全匹配，故加上首尾符号"^"和"$"；
    let regex1 = new RegExp('^' + newStr1 + '$');
    //如匹配，则output值由false转变为true；
    if (newStr2.match(regex1)) {
        output = true;
    }
    //如不匹配，输出output初始值false；
    return output;
}
console.log(checkWildcard(line1, line2));
```
简洁一点
```js
    line = await readline();
    str1 = line.toLowerCase();
    str1 = str1
        .replace(/\?/g, "[a-z0-9]")
        .replace(/\./g, ".")
        .replace(/\*/g, "[a-z0-9]*"); //把字符串中的通配符转为正则表达式可以识别的字符
    let reg = new RegExp(`^${str1}$`); //给正则表达式加上限定符
    line = await readline();
    let str2 = line.toLowerCase();
    console.log(reg.test(str2));
```
但很可惜，这样会超时，最后一组测试用例不通过
