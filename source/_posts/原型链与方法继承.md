---
title: 原型链与方法继承
---
# 原型链
## 引入
在调用实例的方法时，往往没有在实例中直接定义的方法，而是要从它的构造函数中找，而构造函数（特别是工厂函数）创建的示例也都会有这些定义的方法，就构建了一个从实例到构造函数的链。
这是一个“溯源”的过程，一步步向前寻找方法的过程就形成了链条

但是在后面的方法继承中，我们会看到实例并不能访问构造函数的方法，而是访问其原型对象的方法
## 原型对象prototype
**函数才拥有prototype属性**
它是函数的一个属性，指向一个对象，称为原型对象
这个对象上定义了，所有通过这个函数构建的实例所共有的方法
看到prototype，就应想到它本身是一个函数，并且有一堆定义给实例的方法
*它是为了构造函数存在的*

##  __ proto__属性
**对象和方法都拥有__proto__属性**
它是对象的一个属性，指向创建它的构造函数的原型对象
看到 __ proto__，就应想到类型判断，这个对象由上一级函数构建
*它是为了溯源存在的*

## constructor构造器
**每个实例对象都有constructor属性**
它是对象的一个属性，指向创建它的构造函数
看到constructor，就应想到工厂函数，定义了一堆相同的属性和方法
# 静态方法，实例方法，原型方法
三种方法是围绕着构造函数与其创建的实例，二者所能调用的方法展开的
## 静态方法
静态函数是指，构造函数创建的实例，不能调用构造函数本身有的方法
```JavaScript
function Person (){
    
}
 
Person.sayHello = function(){   // 这种形式定义的是静态方法
    console.log("Hello!");
}
 
var p1 = new Person();
console.log(p1);    // Object{ }
Person.sayHello();  // Hello!
p1.sayHello();      
// 报错，Person里面的sayHello方法就是静态方法，创建的实例不可以调用，一调用就会报错。而构造函数本身可以调用。
```
## 实例方法
顾名思义，实例方法是创建的实例才能调用的方法
关键在于，构造函数中对this设置方法，this会指向new构造出的实例；
否则该方法只会属于构造函数
```JavaScript
function Person (){
    this.sayHello = function(){   // 这种形式定义的sayHello就是实例方法
        console.log("Hello!");
    }
}
 
var p1 = new Person();
Person.sayHello();  //报错，构造函数未定义该方法，用this定义的该方法只是给实例定义的，只有实例可以调用
p1.sayHello();      //实例可以调用，输出"Hello!"
 
var p2 = new Person();
console.log(p1.sayHello == p2.sayHello);   // false
console.log(p1.sayHello === p2.sayHello);  // 输出false，每个实例在创建时都会定义sayHello方法，每个实例的该方法都是自己特有的，不与其它实例共有，所以每个实例的该方法不是同一个。
```
## 原型方法
原型方法指的是，实例可以调用，而构造函数不能调用的方法
该方法定义在构造函数的原型上，也是一种常见的构造class的形式
```JavaScript
function Person (){
   	
}
 
Person.prototype.sayHello = function(){    // 定义的是原型方法
    console.log("Hello!");
}
 
var p1 = new Person();
p1.sayHello();   //实例可以调用原型方法，输出："Hello!"
Person.sayHello();  //报错，构造函数不可调用它自己原型上的方法，只有它创建的实例可以调用它原型上的方法
 
var p2 = new Person();
p2.sayHello();
console.log(p1.sayHello === p2.sayHello); // true  因为是在构造函数的原型上定义的方法，每个实例本身并没有该方法，实例调用的给方法均来自于原型上的，每个实例调用的都是同一个
```
*这其中的联系，就是原型链的知识*
## 实例方法优先级
从上面的例子知道，为实例创建方法有三种办法：
直接定义，实例方法定义，原型方法定义，其定义优先级为
直接定义 > 实例定义 > 原型定义
```JavaScript
var BaseClass = function() {  
    this.method1 = function(){  
     }  // by this
};  
var instance1 = new BaseClass();  
instance1.method1 = function(){  
}  // by directly
BaseClass.prototype.method1 = function(){  
}  // by prototype

instance1.method1();
//Defined directly in the instance method  
```

