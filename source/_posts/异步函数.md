---
title: 异步函数
---
异步函数分为Generator函数和async函数，后者是前者的语法糖
其中Generator是es6语法，async是es7语法，但是已经被babel采用，并且成为现在最通用的异步操作方案

# Generator生成器
异步函数的需求很简单，要求函数执行过程中，对某些节点有严格执行顺序，类似debugger，一节节递进
## 引入
```
{
  // 传统函数
  function foo() {
    return 'hello world'
  }

  foo()   // 'hello world'，一旦调用立即执行


  // Generator函数
  function* generator() {
    yield 'status one'         
    return 'hello world'
  }

  let iterator = generator()  
  iterator.next()   // {value: "status one", done: false}
  iterator.next()   // {value: "hello world", done: true}，
}
```
从逻辑上说，其实generator并没有新增多少特性，只是对整个异步流程做了严谨细致的定义
第一步我们创建了一个generator函数，使用* 标识符，
第二步，在函数内使用yield关键字，规定每一步的状态，
第三步，在后续调用函数的next方法，推动异步操作，调用next直到溢出，yield值变为undefined
## yield规范
yield最好写在括号里
```JavaScript
{
  function* demo() {
    console.log('Hello' + yield); // SyntaxError
    console.log('Hello' + yield 123); // SyntaxError
  
    console.log('Hello' + (yield)); // OK
    console.log('Hello' + (yield 123)); // OK
  }
}
```
嵌套使用时，必须对使用的generator函数作声明
```JavaScript
{
  function* foo() {
    yield 'aaa'
    yield 'bbb'
  }
  function* bar() {
    foo()
    // 必须使用yield* foo()
    yield 'ccc'
    yield 'ddd'
  }

  let iterator = bar()

  for(let value of iterator) {
    console.log(value)
  }
  // ccc
  // ddd
}
```
## next()方法
next方法只有两个作用：推动遍历器执行，和传参
next方法返回一个对象，value表示状态标识，done表示是否完成流程
next方法可以传参，传入参数将代替yield及其后面的状态标识
通常，不需要专门为next传参，只调用next()保证异步操作执行即可
```JavaScript
fucntion* add(){
	console.log("start");
	let x = yield "2";// yield "2" 被替换为20赋值给x
	console.log("one:" + x);
	let y = yield "3";// yield "3" 被替换为30赋值给y
	console.log("two:" + y);
	return x + y// return也是yield的一部分，相当于yield (x+y)
}
const fn = add();
console.log(fn.next());
console.log(fn.next(20));
console.log(fn.next(30));
// 输出结果依次为
// start
// {value:'2',done:false}
// one:20
// {value:'3',done:false}
// two:30
// {value:50,done:true}
```
# Iterator迭代器
实际上，Generator生成器是一类特殊的函数，它会返回一个对象，称为Iterator迭代器，用于遍历数据
*详细的内容，属于迭代与遍历，此处不多介绍*
我们只需要知道，Generator的核心就是Iterator即可
此处展示一个用es5构造的迭代器说明其构造与效果
```JavaScript
function createIterator(items) {
    var i = 0;
    return {
        next: function() {
            var done = (i >= items.length);
            var value = !done ? items[i++] : undefined;
            return {
                done: done,
                value: value
            };
        }
    };
}
// 此处模仿Generator的流程
var iterator = createIterator([1, 2, 3]);
console.log(iterator.next()); // "{ value: 1, done: false }"
console.log(iterator.next()); // "{ value: 2, done: false }"
console.log(iterator.next()); // "{ value: 3, done: false }"
// 之后的所有调用
console.log(iterator.next()); // "{ value: undefined, done: true }"
```
# async
## 简单用法
实际上，async函数就是Generator函数的封装，将* 替换成async，将yield替换成await
不同的是，使用async可以不再调用next方法，而是自动执行
这是一个加载资源的例子，可以看到异步调用的流程已经非常简洁
```JavaScript
import { getMusicList } from "@/request/api/home.js"
...
methods:{
	// 在一个需要异步流程的函数前，使用async声明
	async getmusiclist() {
		// 在流程中，使用await对流程节点声明
        let res = await getMusicList()
        this.musicList = res.data.result
    }
},
mounted(){
	this.getmusiclist()// 在加载资源时进行调用
}
```
## 延伸
async声明的函数，会返回一个Promise对象
```JavaScript
class Storage {
  constructor() {
    this.cachePromise = caches.open('avatars');
  }

  async getAvatar(name) {
    const cache = await this.cachePromise;
    return cache.match(`/avatars/${name}.jpg`);
  }
}

const storage = new Storage();
storage.getAvatar('jake').then(…);
```

# 三者对比实例
还是得感谢阮一峰老师的笔记给出的例子
一系列动画，用三种方案来写，要求是：
假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。
## Promise方案
```JavaScript
function chainAnimationsPromise(elem, animations) {

  // 变量ret用来保存上一个动画的返回值
  let ret = null;
  let p = Promise.resolve();

  for(let anim of animations) {
    p = p.then(function(val) {
      ret = val;
      return anim(elem);
    });
  }
  // 返回一个部署了错误捕捉机制的Promise
  return p.catch(function(e) {
    /* 忽略错误，继续执行 */
  }).then(function() {
    return ret;
  });
}
```

## Generator方案
其中的spawn表示自动执行器
```JavaScript
function chainAnimationsGenerator(elem, animations) {

  return spawn(function*() {
    let ret = null;
    try {
      for(let anim of animations) {
        ret = yield anim(elem);
      }
    } catch(e) {
      /* 忽略错误，继续执行 */
    }
    return ret;
  });

}
```
## async方案
```javaScript
async function chainAnimationsAsync(elem, animations) {
  let ret = null;
  try {
    for(let anim of animations) {
      ret = await anim(elem);
    }
  } catch(e) {
    /* 忽略错误，继续执行 */
  }
  return ret;
}
```
async方案肉眼可见的省事
