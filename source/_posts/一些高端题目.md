---
title: 一些高端题目
---
# 闭包的提权漏洞
[闭包的提权漏洞](https://www.bilibili.com/video/BV1Au4y1J7pz)
```js
var o = (function(){
	var obj = {
		a:1,
		b:2,
	}
	return {
		get: function(key){
			return obj[key]
		}
	}
})();
// 要求在不改变上述代码前提下修改obj对象
```
首先，它是个闭包，调用o.get(a)时，将参数传入作为内部obj的键访问
o本身返回一个对象，其中只有一个get方法，无法访问到o.obj
## 思路：原型链
利用原型链上的方法，也就是Object.prototype
注意到valueOf方法可以返回对象本身
只要想办法调用到o.obj.valueOf就成功了
**注意对象的键必须为字符串**
但是如果直接将valueOf当成key传进去，调用o.get('valueOf')
报错``TypeError:Cannot convert undefined or null to object``
## 错误：this指向问题
valueOf的源码如下：
```js
Object.prototype.valueOf = function(){
	return Object(this)
}
```
也就是说valueOf的抛出结果完全取决于this指向
题目中调用valueOf的本质如下：
```js
const obj = {};
const v = obj.valueOf;//注意不是obj.valueOf()
v();
```
也就是说先保存结果再调用，我们希望this指向o.obj，但是**到底指向哪里了呢**
*实际上上面的报错是将null和undefined类型转化为object导致的，所以大概率是undefined.valueOf()导致报错*
## 改正：采用getter访问
*详情见getter与setter*
```js
Object.defineProperty(Object.prototype,'abc',{
	get(){
		return this
	}
})
console.log(o.get('abc'))
```
此时就能访问到o.obj了
## 防范：修改原型链
```js
Object.setProptotypeOf(obj,null)
```
断开obj的原型链，对null无法赋值
等价于
```js
var obj = Object.create(null)
```
还有一种不修改的方法，在obj.get做文章
```js
get:function(k){
	if(obj.hasOwnProperty(k){
		return obj[k]
	})// 不存在默认返回undefined
}
// 不能使用in 会触发原型链访问
```
