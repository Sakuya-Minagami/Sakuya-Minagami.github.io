---
title: 力扣
---

# 数组中心索引

```js
var pivotIndex = function (nums) {
    let sum = 0, left = 0
    nums.forEach(num => sum += num) //先求和
    for(let i = 0; i < nums.length; i++) {
        if(i > 0) left += nums[i - 1]
        if(left * 2 === sum - nums[i]) return i
    }
    return -1
};
```
# 搜索插入位置
```js
var searchInsert = function(nums, target) {
    if(target > nums[nums.length-1]){
        return nums.length
    };
    for(let i=0;i<nums.length;i++){
        if(target <= nums[i]){
            return i
        }
    } 
};
```
解答：
```js
//合并调节，二分查找的修改
var searchInsert = function(nums, target) {
    const n = nums.length;
    let left = 0, right = n - 1, ans = n;
    while (left <= right) {
        let mid = ((right - left) >> 1) + left;
        if (target <= nums[mid]) {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return ans;
};

```
# 合并两个有序数组
```js
var merge = function(nums1, m, nums2, n) {
    for(let i=m;i<m+n;++i){
        nums1[i] = nums2[i-m]
    }
    nums1.sort((a,b) =>a-b)
};
```
# 原地移除元素
**这就是双指针**
```js
var removeElement = function(nums, val) {
    var index = 0;
    nums.forEach(function(item){
        if(item !== val){
            nums[index++] =item
        }
    })
    nums.length = index
};
```
# 有效括号
注意不一定先小括号后中括号再大括号
主要是replace太好用了，消消乐写法
```js
var isValid = function(s) {
	let len =s.length;
	if(len % 2 !==0 ){
		return false;
	}
 	let length = len / 2;
		for (let i = 0; i < length; i++) {
			s = s.replace("()", "");
			s = s.replace("{}", "");
			s = s.replace("[]", "");
		}

	return s.length === 0;
};
```
主流是堆栈写法
```js
var isValid = function(s) {
	let stack = [];
    for(i=0;i<s.length;++i){
        const start = s[i];
        if(start == '(' || start == '[' || start == '{'){
            stack.push(start);
        } else {
            const end = stack[stack.length-1];
            if(start == ')'&& end=='(' ||
                start == '}'&& end=='{' ||
                start == ']'&& end=='['){
                    stack.pop()
                } else {
                    return false
                }
        }
    }
    return stack.length === 0
};
```
# 有序数组去重
没参考答案写出来的双指针，可喜可贺
```js
var removeDuplicates = function(nums) {
    var ref = 0;
    for(let i=0;i<nums.length;i++){
        if(nums[i] !== nums[i-1]){
            nums[ref++] = nums[i]
        }
    }
    return ref
};
```
# 最大股票利润问题
也就是动态规划问题，是一个新的方向
核心思想是将每一天的利润转化为前一天的和今天的比较
遍历在每一天出售的情况，利润要么是前一天已知的最大利润，要么是当日售价减去过去最小买价
```js
var maxProfit = function(prices) {
    let buy = Infinity;
    let profit = 0;
    for(let price of prices) {
        buy = Math.min(buy, price);//找最小买入值
        profit = Math.max(profit, price - buy);//更新最大利润值
    }
    return profit;
};
```
*本题仅限一次买入卖出，之后还有更复杂的情形，比如多次，比如手续费*
# 反转链表
看过思路后自己写，值得祝贺
*奇妙的双指针*
```js
var reverseList = function(head) {
    var cur = head;
    var pre = null;
    var temp = head;
    while(cur !== null){
        temp = cur.next;// 保存下一个节点
        cur.next = pre;// 节点回指
        pre = cur;// 右移双指针
        cur = temp;
    }
    return pre
};
```
# 爬楼梯问题
显然的递归，但是直接套函数会超时
```
function f(n){
	return f(n-1) + f(n-2)
}
```
解答给的直接求数列方法很好
```js
var climbStairs = function(n) {
    let a1 = 0;
    let a2 = 1;
    let a3 = 1;
    for(let i=0;i<n;++i){
        a1 = a2;
        a2 = a3;
        a3 = a1 + a2;
    }
    return a2
};
```
# 字符串反转
这个面试考过，秒了很爽
主要是用上了解构的办法，交换很清晰
```js
var reverseString = function(s) {
    const len = s.length;
    for(let i=0;i<s.length/2;++i){
        [s[i],s[len-1-i]] = [s[len-1-i],s[i]]
    }
};
```
# 合并有序链表
还是很难想到这个递归
```js
var mergeTwoLists = function(list1, list2) {
    if(list1 === null){
        return list2
    }else if(list2 === null){
        return list1
    }else{
        if(list1.val >list2.val){
            list2.next = mergeTwoLists(list1,list2.next)
            return list2
        }else{
            list1.next = mergeTwoLists(list2,list1.next)
            return list1
        }
    }
};
```
# 字符串最长公共前缀
其实是一个怎么考虑遍历的问题，注意细节
```js
var longestCommonPrefix = function(strs) {
    var ref = strs[0];
    var ans = [];
    const len = ref.length;
    for(let i=0;i<len;i++){
        for(let j=1;j<strs.length;j++){
            if(!strs[j].charAt(i) || strs[j][i] !== ref[i]){
                return ans.join("")// 数组转字符串
            }
        }
        ans.push(ref[i])
    }
    return ans.join("")// 数组转字符串
};
```
# 二分查找
其实这个比二分插入简单的多，但还是边界问题
left<=right很重要
```js
var search = function(nums, target) {
    var left = 0;
    var right = nums.length-1;
    var mid;
    while(left <= right){
        mid = Math.floor((left + right)/2);
        if(nums[mid] === target){
            return mid;
        }else if(target < nums[mid]){
            right = mid -1;
        }else {
            left = mid + 1;
        }
    }
    return -1
};
```
# 判断链表有环
其实已经知道是快慢指针，但是不清楚边界条件
```js
var hasCycle = function(head) {
    if(head === null) return false
    var fast = head.next;
    var slow = head;
    while(fast && fast.next){
        if(slow.next === fast.next.next){
            return true
        }
        fast = fast.next;
        fast = fast.next;
        slow = slow.next;
    }
    return false
};
```
# 多数元素
找到数组中超过一半的元素并输出
最简单是排序，一半处的数即为最多的
```js
var majorityElement = function(nums) {
    nums.sort((a,b) => a-b);
    return nums[Math.floor(nums.length/2)]
};
```
称为摩尔投票法，其实也是动态规划，从前n-1个数与第n个数比较
```js
var majorityElement = function(nums) {
    var ref = nums[0];
    var count = 0;
    for(let i=0;i<nums.length;i++){
        if(nums[i] !== ref){
            count--;
        }else{
            count++
        }
        if(count < 0){
            ref = nums[i];
            count = 0;
        }
    }
    return ref
};
```
# 转圈游戏
其实思路很简单，就是可能会莫名卡住
```js
var circularGameLosers = function(n, k) {
   var arr = [];
   var index = 0;
   var times = 1;
   for(let i=1;i<=n;++i){
       arr.push(i)
   } 
   while(arr[index]>0){
       arr[index] *= -1;
       index = (index + times * k ) % n;
       times++;
   }
   return arr.filter(num => num > 0)
};
```
# 二叉树合并
二叉树也忘光了，算是康复训练
主要还是递归
```js
var mergeTrees = function(root1, root2) {
    if(root1 === null) return root2;
    if(root2 === null) return root1;
    return new TreeNode(root1.val + root2.val,
    mergeTrees(root1.left,root2.left),
    mergeTrees(root1.right,root2.right))
};
```
# 二叉树中序遍历
本来想在函数本身递归的，但是注意到ans会在递归中重置
需要新开函数inorder，本身不返回值但会按顺序push入栈
换句话说，inorder函数是遍历顺序的体现
```js
var inorderTraversal = function(root) {
    var ans = [];
    const inorder = (root) => {
        if(root === null) return ;
        inorder(root.left);
        ans.push(root.val);
        inorder(root.right);
    }
    inorder(root);
    return ans
};
```
# 整数的各位积和之差
想到用字符串直接拆解，不过要记得转回数字
```js
var subtractProductAndSum = function(n) {
    var sum = 0;
    var mul = 1;
    const str = n.toString();
    for(let i=0;i<str.length;++i){
        sum += parseInt(str[i]);
        mul *= parseInt(str[i]);
    }
    return mul - sum
};
```
# 最多城堡数

```js
var captureForts = function(forts) {
    let ans = 0, pre = -1;
    for (let i = 0; i < forts.length; i++) {
        if (forts[i] == 1 || forts[i] == -1) {
            if (pre >= 0 && forts[i] != forts[pre]) {
                ans = Math.max(ans, i - pre - 1);
            }
            pre = i;
        }
    }
    return ans;
};
```
# 检验二叉树对称
```js
var isSymmetric = function(root) {
    function f(p,q){
        if(p === null && q === null){
            return true
        }else if(p === null || q === null){
            return false
        }else if(p.val !== q.val){
            return false
        }else{
            return f(p.left,q.right) && f(p.right,q.left)
        }
    }
    return f(root.left,root.right)
};
```
# 删除指定节点
主要是设置一个虚拟头节点
```js
var removeElements = function(head, val) {
    const pre = new ListNode(0, head);
    var cur = pre;
    // 注意 一定要设置条件为cur.next否则访问不到报错
    while(cur.next !== null){
        if(cur.next.val === val){
            cur.next =  cur.next.next;
            continue;
        }
        cur = cur.next
    }
    return pre.next
};
```
# 交换二叉树
没想到会是声明赋值出错，注释的写法会影响后续的递归
```js
var invertTree = function(root) {
    if(root === null){ 
        return null
    };
    // root.left = invertTree(root.right);
    // root.right = invertTree(root.left);
    const left = invertTree(root.left);
    const right = invertTree(root.right);
    root.left = right;
    root.right = left;
    
    return root
};
```
# 相交链表
主要是最终双指针一定能同时为null跳出循环没想到
```js
var getIntersectionNode = function(headA, headB) {
    var p = headA;
    var q = headB;
    if(headA === null || headB === null) return null;
    while(p !== q){
        p = p === null ? headB : p.next;
        q = q === null ? headA : q.next
    }
    return q
};
```
# 回文字符串
正则匹配还是用不惯
```js
var isPalindrome = function(s) {
    s=s.replace(/[^a-zA-Z0-9]/g,"").replace(/\s/g,"").toLowerCase();
     return s===[...s].reverse().join("")
};
```
# 回文链表
注意数组不能使用=== 判断，会认定为object为true
```js
var isPalindrome = function(head) {
    let p = head;
    let arr = [];
    while(p !== null){
        arr.push(p.val);
        p = p.next
    }
    return arr.join("") === arr.reverse().join("")
};
```
# 种花问题
关键：通过补0避免讨论边界条件
以及直接对原数组修改，符合条件直接种花
```js
var canPlaceFlowers = function(flowerbed, n) {
    flowerbed.unshift(0);
    flowerbed.push(0);
    let count = 0;
    for(let i=0;i<flowerbed.length;i++){
        if(flowerbed[i-1] === 0 && flowerbed[i] === 0 && flowerbed[i+1] === 0){
            flowerbed[i] = 1;
            count++
        }
    }
    return count >= n
};
```
# 异位词
排序法最轻松，主要是写一下哈希法
创建表，表元素为``['a',1]``
```js
var map = new Map();   
     for (var n of s) {      
         if (map.has(n)) {
             map.set(n, map.get(n) + 1); 
         } else {
             map.set(n, 1);         
         }
     }
```
遍历t
```js
for (var n of t) {            
         if (map.has(n) && map.get(n) > 0) { 
               map.set(n, map.get(n) - 1);   
               //每找到一个，键值-1；
         }else{                     
             return false;
         }
     }  
return true; //循环结束后为s与t异位,必定t中的元素在s的map中都能找到
```
应该没办法直接比较s和t的表，所以退一步，依次比较到最后的视为匹配
# 二叉树路径总和
第一时间想到的是递归，注意边界条件，确定初始节点为空和到达叶子结点的条件，以及全程的返回值
```js
var hasPathSum = function(root, targetSum) {
    if(root === null) return false;
    if(root.left === null && root.right === null){
        return root.val === targetSum;
    }
    return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val)
};
```
# 二叉树最小深度
同样是边界条件没做好，忽略了没有子树的情况，
```js
var minDepth = function(root) {
    let ans = Infinity;
    if(root === null) return 0;
    if(root.left === null && root.right === null){
        return 1
    }else {
        if(root.left != null) {
            ans = Math.min(minDepth(root.left), ans);
        }
        if(root.right != null) {
            ans = Math.min(minDepth(root.right), ans);
        }
        return ans + 1;
    }
   
};
```
# 有序数组的平方
输入递增输出也递增，排序法不写了
主要是双指针法，很新奇，时间复杂度为O(n)
思路是大值在两端，小值在中间，用双指针从两边遍历
```js
var sortedSquares = function(nums) {
    let i = 0;
    let j = nums.length-1;
    let ans = [];
    let index = nums.length-1;
    while(i <= j){
        if(nums[i] * nums[i] >= nums[j] * nums[j]){
            ans[index] = nums[i] * nums[i];
            index--;
            i++
        }else{
            ans[index] = nums[j] * nums[j];
            index--;
            j--
        }
    }
    return ans
};
```
# 寻找只出现一次数
主要是异或思路
```js
var singleNumber = function(nums) {
    let ans = 0;
    nums.forEach((item) => {
        ans = item ^ ans;
    })
    return ans
};
```
# 二进制求和
主要是会溢出，不然转十进制很简单
关键点是补零和进位的考虑
这里一个比较好的思路是初始化flag=0，每次循环最后更新进位数flag，最后讨论是否需要进位增1
```js
var addBinary = function(a, b) {
    let maxlen = Math.max(a.length,b.length);
    a = a.padStart(maxlen, 0);
    b = b.padStart(maxlen, 0);
    let ans = [];
    let flag = 0;
    for(let i=maxlen-1;i>=0;--i){
        let c = parseInt(a[i]) + parseInt(b[i]) + flag;
        if(c > 1){
            ans[i] = c-2;
            flag = 1;
        }else{
            ans[i] = c;
            flag = 0;
        }
    }
    if(flag){
        ans.unshift(1)
    }
    return ans.join("")
};
```
# 杨辉三角
一个致命的问题：当返回的是双层数组的时候，返回值不能采用构造法，而必须采用赋值法
因为直接传入的数组是引用值，会随时被后续修改，要用就必须替换掉
```js
var generate = function(numRows) {
    let ans = [[1]];
    let row = [1];
    for(let i=0;i<numRows-1;i++){
        let temp = new Array(...row);// 创建新数组，跟row独立
        if(i === 0){
            temp = [1];// new Array语法只传一个数字会表示新数组长度，这里重新修改temp
        }
        temp.push(0)// 右添0错开
        row.unshift(0);// 左添0错开
        for(let j=0;j<row.length;j++){
            row[j] += temp[j];
        }
        ans.push([...row]);// es6标准，展开运算符，保证push的是新创建的数组
    }
    return ans
};
```
# 字符串同构
哈希表还是不熟
```js
var isIsomorphic = function(s, t) {
    const s2t = {};
    const t2s = {};
    const len = s.length;
    for (let i = 0; i < len; ++i) {
        const x = s[i], y = t[i];
        if ((s2t[x] && s2t[x] !== y) || (t2s[y] && t2s[y] !== x)) {
            return false;
        }
        s2t[x] = y;
        t2s[y] = x;
    }
    return true;
};
```
# 寻找重复元素2
非常简洁的map使用，最精彩的是在不断向右遍历的过程中，要寻找最小的距离，就要每次重复都更新i值
```js
var containsNearbyDuplicate = function (nums, k) {
    const map = new Map();
    for (let i = 0; i < nums.length; i++) {
        if (map.has(nums[i]) && i - map.get(nums[i]) <= k) {
            return true;
        } else {
            map.set(nums[i], i);
        }
    }
    return false;
};
```
# 队列实现栈
有些复杂
```js
var MyStack = function() {
    this.queue = [];
    this._queue = [];
};

/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    return this.queue.push(x)
};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
    while(this.queue.length > 1){
        this._queue.push(this.queue.shift());// queue末尾接到_queue前端
    }
    let ans = this.queue.shift();
    while(this._queue.length){
        this.queue.push(this._queue.shift());// _queue末尾接到queue前端
    }
    return ans
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
    return this.queue.slice(-1)[0];
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return this.queue.length === 0
};

```
# 二叉树所有路径
主要是想清楚在什么地方递归，箭号的位置在哪
递归的边界依然是叶节点
```js
var binaryTreePaths = function(root) {
    const paths = [];
    const construct_paths = (root, path) => {
        if (root) {
            path += root.val.toString();
            if (root.left === null && root.right === null) {
                paths.push(path);
            } else {
                path += "->";
                construct_paths(root.left, path);
                construct_paths(root.right, path);
            }
        }
    }
    construct_paths(root, "");
    return paths;
};
```
# 各位相加
即数字根问题
一定要注意为什么是``(sum -1 ) % 9 + 1``，其范围从1到9
sum%9范围从0到8

```js
var addDigits = function(num) {
    const str = num.toString();
    var sum = 0;
    for(let i=0;i<str.length;i++){
        sum += parseInt(str[i]);
    }
    return (sum -1 ) % 9 + 1
};
```
# 第一个错误版本
先存一下没写完的思路
```js
var solution = function(isBadVersion) {
    /**
     * @param {integer} n Total versions
     * @return {integer} The first bad version
     */
    return function(n) {
        let m = 1;
       while(n > m*(m+1)/2){
           m++;
       }
       let later = n;
       let early = n - m;
       let flag = 1;
       while(flag){
           if(early < 1) early = 1;
           if(isBadVersion(early)){
               
           }
       }
    };
};
```
正常还是用二分法
**一定要注意区间条件**
```js
var solution = function(isBadVersion) {
    /**
     * @param {integer} n Total versions
     * @return {integer} The first bad version
     */
    return function(n) {
       var early = 1;
       var later = n;
       while(early < later){
           var mid = Math.floor((later - early)/2 + early);
           if(isBadVersion(mid)){
               later = mid;
           }else {
               early = mid + 1;
           }
       }
       return later
    };
};
```
## 专题：二分法边界条件
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
```js
var searchInsert = function(nums, target) {
  let left = 0
  let right = nums.length
  if(nums[0] > target) { return 0}
  while(left < right){
    let mid = Math.floor(left + (right - left)/2)
    if(nums[mid] < target){
      left = mid + 1
    }else if(nums[mid] > target){
      right = mid
    }else {
      return mid
    }
  }
  return left
};
```
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
```js
var search = function(nums, target) {
  let left = 0
  let right = nums.length
  while(left < right){
    let mid = Math.floor(left + (right - left)/2)
    if(nums[mid] < target){
      left = mid + 1
    }else if(nums[mid] > target){
      right = mid
    }else{
      return mid
    }
  }
  return -1
};
```
区间：``[left,right)``，由``while(left < right)``决定
因为可搜索时left和right一定不等
重置区间：``left = mid + 1``，由区间决定
保证每次都一定会缩小区间，同理``right = mid``
返回：left，由区间决定，因为left一定是最满足的
# 单词规律
同样是字符串同构匹配，使用哈希表
关键在映射条件的判定
```js
var wordPattern = function(pattern, s) {
    var pre = 0;
    arr = [];
    for(let i=0;i<s.length;i++){
        if(s[i] === " "){
            arr.push(s.slice(pre,i));
            pre = i + 1;
        }
    }
    arr.push(s.slice(pre,s.length));
    // 注意数组不等长是可能判定同构的 这里要求映射和数量都要相等
    if(arr.length !== pattern.length) return false;
    let map1 = new Map();
    let map2 = new Map();
    for(let j=0;j<pattern.length;j++){
        const x = pattern[j];
        const y = arr[j];
        if((map1.has(x) && map1.get(x) !== y) || (map2.has(y) && map2.get(y) !== x)){
            return false
        }else {
            map1.set(x,y);
            map2.set(y,x);
        }
    }
    return true
};
```
# 两数交集
注意两个数组地位相同，排序以后是不清楚谁的初始下标更小的
所以不能遍历其中一个坐标，而是两个坐标动态移动
```js
var intersect = function(nums1, nums2) {
    nums1.sort((a,b) => a-b);
    nums2.sort((a,b) => a-b);
    let l = 0, r = 0, ans = [];
    while (l < nums1.length && r < nums2.length) {
        if (nums1[l] === nums2[r]) {
            ans.push(nums1[l]);
            l++;
            r++;
        } else nums1[l] < nums2[r] ? l++ : r++;
    }
    return ans
};
```
# 字符串中第一个唯一字符
用同下标法确实最简单
```js
var firstUniqChar = function(s) {
    for(let i = 0; i < s.length; i++) 
        if (s.indexOf(s[i]) === s.lastIndexOf(s[i]))
            return i
    return -1
};
```
哈希法
```js
var firstUniqChar = function(s) {
    let map = new Map();
    let i = -1;
    while (++i < s.length){
        map.set(s[i], map.has(s[i]) ? -1 : i);
    }
    i = -1;
    map.forEach((item, _, map) => {
        if(item !== -1){
            i = item; 
            map.clear();
        }
    })
    return i
};
```
# 盛最多水的容器
本来以为是动态规划的题，但是可以进一步简化思路
采用双指针，因为规划量``S = (j-i)*min(height[i],height[j])``中，j-i可以通过双指针相互逼近，保证已经提前取到最大的j-i
还有一个重点，双指针移动先移动矮柱子，因为移动高柱子一定对规划量是负贡献
```js
var maxArea = function(height) {
    let res = 0
    for (let i = 0, j = height.length - 1; i < j; ) {
        res = Math.max(res, Math.min(height[i], height[j]) * (j - i))
        height[i] < height[j] ? i++ : j--
    }
    return res
};
```
# 四数之和
主要是关于自己思路的错误
一方面是把continue和break忘得差不多了
continue是跳过下面代码进入下层循环，break则是直接终止循环
之前没写break导致双指针left和right一直在while里没动出不去
但是我采用了i左j右的遍历形式，从两边逼近
```js
var fourSum = function(nums, target) {
    nums.sort((a,b) => a-b);
    console.log(nums)
    var ans = [];
    for(let i=0;i<nums.length;i++){
        for(let j=nums.length-1;j-2>i;j--){
            var left = i+1;
            var right = j-1;
            while(left < right){
                const sum = nums[i]+nums[j]+nums[left]+nums[right];
                console.log(left,right)
                if(sum === target){
                    ans.push([nums[i],nums[j],nums[left],nums[right]]);
                    break;// 很重要
                }else {
                    sum < target ? left++ : right--;
                }
            }
        }
    }
    return ans
};
```
# 组合总数
同样是dfs，想到这个迭代规则不容易，要确定边界更不容易
确定一个二叉树，节点输入已经选用的数字池pool，目标target，当前参考下标index
左树搜索池子pool不改变，index右移的可能
右树搜索参考值入池，index不变的可能
该过程会遍历所有可能target
边界条件为target为0，收入答案；或者下标越界，``index === candidates.length``
其实看懂不难，但是思路清晰很难，一开始无论如何都收敛不到边界然后爆栈
```js
var combinationSum = function(candidates, target) {
    var ans = [];
    function dfs(pool,target,index){
        if(index === candidates.length) return ;
        if(target === 0){
            ans.push(pool);
            return ;
        }
        dfs([...pool],target,index+1);
        if(target >= candidates[index]){
            dfs([...pool,candidates[index]],target-candidates[index],index);
        }
    }
    dfs([],target,0);
    return ans
};
```
# 跳跃游戏
难得自己想出来，结果时间空间都糟糕，啊哈哈
不过自己的想法也有点看头，用动态规划的考虑，构造次数数组，每次考虑次数都从之前写在该处的次数开始（因为每个地方一定跳得到，所以之前一定会在这个地方赋值time）
```js
var jump = function (nums) {
    var times = [0,];
    const write = (i, time) => {
        time++;
        for (let j = 1; j <= nums[i]; j++) {
            if (!times[i + j]) {
                times[i + j] = time;
            }
        }
    }
    for (let i = 0; i < nums.length; i++) {
        write(i,times[i]);
    }
    return times[nums.length - 1]
};
```
用贪心算法最好，到达最后一格的一定是从左边最近的
```js
var jump = function (nums) {
    var index = nums.length-1;
    var step = 0;
    while(index > 0){
        for(let left = 0;left < index;left++){
            if(nums[left] + left >= index){
                index = left;
                step++;
                break;
            }
        }
    }
    return step
};
```
关键是index从右边开始找最近路线，left从左边找最远距离
# 全排列
自己写的，干净又整洁，时间空间都高
```js
var permute = function(nums) {
    var ans = [];
    const dfs = (to) => {
        if(to.length === nums.length){
            ans.push(to);
        }
        for(let i=0;i<nums.length;i++){
            if(!to.includes(nums[i])){
                dfs([...to,nums[i]])
            }
        }
    }
    dfs([]);
    return ans
};
```
# pow（x，n）
用循环会超时，分治法复杂度为logn
```js
var myPow = function(x, n) {
    if(n === 0) return 1;
    if(n < 0) return 1/myPow(x,-n);
    if(n % 2 === 0){
        return myPow(x * x,n/2)
    }else {
        return x * myPow(x,n-1)
    }
};
```
# 最大子数组和
想清楚不容易，不过列出动态规划转移方程就好了
```js
var maxSubArray = function(nums) {
    var sum = nums[0];
    var pre = 0;
    nums.forEach( item => {
        pre = Math.max(pre + item,item);// 每次都会扫描当前索引下最长子串
        sum = Math.max(sum,pre);// 所有记录过的最长串比较
    })
    return sum
};
```
# 跳跃游戏
自己想的代码
```js
var canJump = function(nums) {
    var max = 0;
    var ans = true;
    nums.forEach( (item,index) => {
        if(max < index){
            ans = false;
        }else {
            max = Math.max(index + item,max);
        }
    })
    return ans
};
```
别人给的思路，反向查找，很清晰并且复杂度很低
```js
var canJump = function(nums) {
    var end = nums.length-1;
    for(let i=nums.length-2;i>=0;i--){
        if(nums[i] + i >= end){
            end = i;
        }
    }
    return end === 0
};
```
# 螺旋矩阵2
一如既往的复杂度糟糕，不过我觉得思路还挺清晰
```js
var generateMatrix = function(n) {
    var arr = new Array(n).fill(0).map( () => new Array(n).fill(0));
    console.log(arr)
    const dir = [[0,1],[1,0],[0,-1],[-1,0]];
    var dir_index = 0;
    var x = 0;
    var y = 0;
    var num = 1;
    const max = n*n;
    while(num <= max){
	    // 每轮修改整行或列数字，碰到边界或者数已填充停止
        while(x >=0 && y >= 0 && x < n && y < n && arr[x][y] === 0){
            arr[x][y] = num;
            x = x + dir[dir_index][0];
            y = y + dir[dir_index][1];
            num++;
        }
        // 回溯
        x = x - dir[dir_index][0];
        y = y - dir[dir_index][1];
        dir_index++;
        if(dir_index === 4) dir_index = 0;
        x = x + dir[dir_index][0];
        y = y + dir[dir_index][1];
    }
    return arr
};
```
# 不同路径2
复杂度还可以，动态规划的训练，讲一下自己觉得巧妙的地方
1，设置``[m+1,n+1]``矩阵，用0填充，保证访问上和左时可以正常访问
2，对有障碍的地方直接设0，因为从上到下和从左到右遍历，所以不会出现设置障碍比计算路径晚的情况
```js
var uniquePathsWithObstacles = function(obstacleGrid) {
    const m = obstacleGrid.length;
    const n = obstacleGrid[0].length;
    if(obstacleGrid[0][0] === 1) return 0;
    var arr = new Array(m+1).fill(0).map(() => new Array(n+1).fill(0));
    arr[1][1] = 1;
    for(let i=1;i<m+1;i++){
        for(let j=1;j<n+1;j++){
            if(i*j === 1) continue;
            if(obstacleGrid[i-1][j-1] === 1){
                arr[i][j] = 0;
            }else {
                arr[i][j] = arr[i-1][j] + arr[i][j-1];
            }
            // console.log(arr,arr[i-1][j],arr[i][j-1],i,j)
        }
    }
    return arr[m][n]
};
```
# 子集
服气了，这么简单想这么久
树形结构想到了，但是没分清是遍历过程push还是遍历结束push
```js
var subsets = function(nums) {
    const n = nums.length;
    var ans = [];
    const dfs = (pool,cur) => {
        if(cur === n){
            ans.push(pool);
            return ;
        }
        dfs([...pool],cur+1);
        dfs([...pool,nums[cur]],cur+1);
    }
    dfs([],0);
    return ans
};
```
# 全部开花最早一天
困难题，没想到代码很简洁
主要是能不能理清题目
解析说的很清楚，解决是否交替播种问题，再解决谁先播种问题，剩下的就是动态规划的处理了
只考虑两颗种子
第一个问题，两颗种子种完的时间一定是固定的，开花时间由后一颗决定，但是前一颗可能因为交替种延后，所以不交替一定是最佳方案
第二个问题，只要最后一颗不是开花时间最短的（假设此时是总体开花时间最短的最优解），那么一定能跟最短的交换顺序，使得总体开花时间更短
```js
var earliestFullBloom = function(plantTime, growTime) {
    var ans = 0;
    var now = 0;
    var arr = [];
    for(let i=0;i<plantTime.length;i++){
        arr.push([plantTime[i],growTime[i]]);
    }
    arr.sort((a,b) => b[1]-a[1]);
    arr.forEach(item => {
        now +=item[0];
        ans = Math.max(ans,now+item[1]);
    })
    return ans
};
```
题解办法，提供了一种构造联合数组的办法
```js
var earliestFullBloom = function (plantTime, growTime) {
    let ans = 0, days = 0;
    for (const [p, g] of _.zip(plantTime, growTime).sort((a, b) => b[1] - a[1])) {
        days += p; // 累加播种天数
        ans = Math.max(ans, days + g); // 再加上生长天数，就是这个种子的开花时间
    }
    return ans;
};
```
# 买卖股票最佳时机2
## 动态规划
这次就是充分的动态规划了，只不过动态转移方程确实有点不好想清楚
规划量为每天结束交易后手持股票和不手持股票的分别最大利润
不持股票时，最大利润为：前一天不持股票最大利润，与前一天持股票再抛出今天股票最大利润
手持股票时，最大利润为：前一天手持股票最大利润，与前一天不持股票再买入今天股票利润最大者
其实主要是后者比较容易纠结，出现负利润还该考虑吗？
应该换个角度，后者表示手上已有股票前提下，找到最节约的购买方式，其实也是变相找到了过去股票最低价

另外，不从动态规划的角度，还应该考虑这样问题：
在已知最小购入价时，我该在一个高价卖出，还是该等后续更高价呢？
我怎么知道是卖掉之后一次高价的钱多还是之后再低价买高价卖多呢？
```js
var maxProfit = function(prices) {
    var arr = new Array(2).fill(0).map(() => new Array(prices.length).fill(0));
    arr[0][0] = 0;
    arr[1][0] = -prices[0];
    for(let i=1;i<prices.length;i++){
       arr[0][i] = Math.max(arr[0][i-1],arr[1][i-1]+prices[i]);
       arr[1][i] = Math.max(arr[1][i-1],arr[0][i-1]-prices[i]); 
    }
    return arr[0][prices.length-1]
};
```
## 贪心算法
贪心算法的解法也很巧妙，将所有买入卖出看成一个区间，区间差即利润
更特别的是，将区间任意分解，利润可以任何作和叠加
因此我们的最大利润就是这些单位区间的筛选和，筛选条件为利润大于0
画成函数会更清楚，收集所有的上坡即可
```js
var maxProfit = function(prices) {
    let ans = 0;
    let n = prices.length;
    for (let i = 1; i < n; ++i) {
        ans += Math.max(0, prices[i] - prices[i - 1]);
    }
    return ans;
};
```
# 环和杆
主要是能用数组维护就尽量用数组
```js
var countPoints = function (rings) {
    const n = rings.length / 2;
    // var bars = new Array(10).fill(0).map(() => new Set());
    var bars = new Array(10).fill(0).map(() => new Array(3).fill(0));
    for (let i = 0; i < n; i++) {
        const j = 2 * i;
        const ring = rings[j];
        const bar = rings[j + 1];
        if(ring === 'R') bars[bar][0] = 1;
        if(ring === 'G') bars[bar][1] = 1;
        if(ring === 'B') bars[bar][2] = 1;
    }
    console.log(bars);
    return bars.filter((item) => !item.includes(0)).length
};
```
