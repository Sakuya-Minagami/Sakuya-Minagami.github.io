---
title: 小小错题集
---
放点笔试题

# es6堆与栈
https://blog.csdn.net/weixin_44907946/article/details/120949485
```
class A {
    String i = "op";
    void func(String s) {
        s = ""+9;
    }
    static void test() {
        A a = new A();
       a.func(a.i);
    }
}
```
问：
1. 变量i,s,a在堆还是在栈中？
2. 第8行执行完后a.i的值是什么？
**1. i,s,a都在栈中，new出来的对象A在堆上。2. 执行完后a.i的值还是字符串op。**
# 引用类型与基础类型，堆与栈
栈：放基本数据类型的变量和值，以及引用类型的变量名和指针
堆：放引用类型的值
# null与undefined
[https://zhuanlan.zhihu.com/p/31067843]
# 常见字符串函数
[https://blog.csdn.net/AIWWY/article/details/114125693]
# 原型链
```js
function A (cName) {
if (cName) {
this.name = cName
}
}
A.prototype.name = 'XiaoMi'
var a = new A()
console.log('A', a.name)

function B (cName) {
this.name = cName
}
B.prototype.name = 'Xiaomi'
var b = new B()
console.log('B', b.name)
```
---
```js
class A {}
class B extends A {}
const a = new A()
const b = new B()
a.proto ===
b.proto ===
B.proto ===
B.prototype.proto ===
b.proto.proto ===

// A.prototype
// B.prototype
// A
// A.prototype
// A.prototype
```
# for循环
```js
var callbacks = []
for (var i = 0; i < 4; i++) {
callbacks.push(function() {
console.log(i);
});
}
callbacks.forEach(cb => cb());
```
# Window Location
[https://blog.csdn.net/terrychinaz/article/details/113684604]
location.hostname 返回 web 主机的域名
location.host 返回 web 主机的域名（包含端口）
location.pathname 返回当前页面的路径和文件名
location.port 返回 web 主机的端口 （80 或 443，如果采用默认的80端口(update:即使添加了:80)，那么返回值并不是默认的80而是空字符。）
location.protocol 返回所使用的 web 协议（http:// 或 https://)
location.href 属性返回当前页面的 URL
location.search 返回?后面部分（包含?）
location.hash 返回锚点（返回值：#xxx）
# 快速排序partition
[https://www.bilibili.com/video/BV19S4y187Rt]
# 渲染和解析
1.  css加载不会阻塞DOM树的解析
2.  css加载会阻塞DOM树的渲染
3.  css加载会阻塞后面js语句的执行
# ajax readyState

0: 还没调用open方法
1: 未调用send方法，也就是还没发送数据给服务器
2: 还没有接收到响应
3: 开始接收到了部分数据
4: 接收完成，数据可以在客户端使用了
# Set()
```js
var set = new Set([0, 2, 2, 0, 0, 5, 9, {}, {}, NaN, NaN]);
console.log(set.size)//7

// 0,2,5,9,Object,Object,NaN
```
顺便，NaN !=NaN
# node定时器
node的定时器共有四种，分别是：setTimeout()，setInterval()，setImmediate()，process.nextTick()
 前两个是语言的标准，后两个是node独有的。
 node的异步任务可以分为两种，分别是追加在 本轮循环 的异步任务和追加在 次轮循坏 的异步任务。本轮循环一定早于次轮循坏执行。
 node规定，process.nextTick和Promise的回调函数，追加在本轮循环，即同步任务一旦执行完成就开始执行他们。而setTimeout、setInterval、setImmediate的回调函数追加在次轮循坏。
# 类型判断
[https://www.jb51.net/article/249332.htm]

```
var a = []
a instanceof Array
  
Array.isArray(a)
  
Object.prototype.toString.call(a) === '[object Array]'

typeof a === 'array'
```
```js
 var iframe = document.createElement('iframe');
     document.body.appendChild(iframe);
 
     var arr = [1,2,3];
     xArray = window.frames[0].Array;  //iframe中的构造函数
     var arrx = new xArray(4,5,6);
 
     console.log(arrx instanceof Array);  //false
     console.log(arrx.constructor == Array);// false
 
     console.log(Array.prototype == xArray.prototype); //false
     console.log(arr instanceof xArray); //false
 
     console.log(arrx.constructor === Array);// false
     console.log(arr.constructor === Array);// true
     console.log(arrx.constructor === xArray);// true
     console.log(Array.isArray(arrx));  //true
```