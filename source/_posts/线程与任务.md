---
title: 线程与任务
---
# 线程问题
原生js是单线程的，它有严格的步骤顺序，可以对dom有严谨操作流程
**单线程的含义是，避免同时和独立进行操作**
现在我们有两个逻辑，分别去修改和删除dom
我们既不能同时去执行两个任务，也不能先执行删除再执行修改
最终的总任务是单线程的任务队列，必须一项一项执行
# 同步与异步模式
我们的编程模式只为了解决两个问题：
将耗时的任务暂时弹出队列
保证某些任务严格的前后关系
## 同步
**同步的定义是 如果在函数返回结果的时候，调用者能够拿到预期的结果(就是函数计算的结果)，那么这个函数就是同步的.**

**要明确，js的单线程是无法改变的，但我们可以改变编程模式**
原生的js模式是同步模式，一旦有任务特别耗时，整个任务就会耽搁
但实际上，如果只是一些ajax请求之类的任务，完全可以挂起，先让别的任务执行
因此我们有了异步模式的方案：
## 异步
```
console.log("a")
console.log("b")
setTimeout(() => { console.log("延时结束") })
console.log("c")
// a b c 延时结束
// 相当于延时操作跳出了队列
```
**我们仍然遵从单线程原则，但是我们可以开启多个子线程**
异步的含义是，回调函数的执行不会影响外界的函数执行。
最开始，我们只有一个窗口，来满足同步需求
现在，我们开了多个窗口，多个窗口间可以相互独立完成，单个窗口内还是可以有严谨的队列顺序
但是最终，经过窗口排完的队一定还是一条
## 实现与事件循环
现在我们可以谈谈整个流程了
（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。
**这三步循环即称为js的事件循环Event Loop**
抽象成生命周期，就是
同步运行栈
nextTick方法
异步任务队列
setImmediate方法（在当前事件循环结束执行，而不是所有事件循环结束）
[js的事件循环机制](https://www.cnblogs.com/cuijinlin/p/13722517.html)
# 宏任务与微任务
异步任务还可细分为宏任务和微任务
队列取任务时，先从微任务取，再从宏任务取
也就是上面的生命周期，在异步任务队列再扩展两项

宏任务有：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering（渲染）
微任务有：process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)
简单记，宏任务就分计时器，网络请求，文件读取，微任务就Promise.then
```JavaScript
//（1）
setTimeout(()=>{
    console.log(1)   // 宏任务
},100)

//（2）
setTimeout(()=>{
    console.log(2)  // 宏任务
},100)

//（3）
new Promise(function(resolve,reject){
    //（4）
    console.log(3)  // 直接打印
    resolve(4)
}).then(function(val){
    //（5）
    console.log(val); // 微任务
})
 
//（6）
new Promise(function(resolve,reject){
    //（7）
    console.log(5)   // 直接打印
    resolve(6)
}).then(function(val){
    //（8）
    console.log(val);  // 微任务
})

//（9）
console.log(7)  // 直接打印

//（10）
setTimeout(()=>{
    console.log(8) // 宏任务，单比（1）(2)宏任务早
},50)

// 结果为3 5 7 4 6 8 1 2
```
具体执行流程为
1.  执行（1），宏任务，调用webapi setTimeout，这个方法会在100ms后将回调函数放入宏任务的任务队列
2.  执行（2），同（1），但是会比（1）稍后一点
3.  执行（3），同步执行new Promise，然后执行（4），直接打印 3 ，然后resolve(4)，然后.then()，把（5）放入微任务的任务队列
4.  执行（6），同上，先打印 5 ，再执行resolve(6)，然后.then()里面的内容（8）加入到微任务的任务队列
5.  执行（9），同步代码，直接打印 7
6.  执行（10），同（1）和（2），只是时间更短，会在 50ms 后将回调 console.log(8) 加入宏任务的任务队列
7.  现在执行栈清空了，开始检查微任务队列，发现（5），加入到执行栈执行，是同步代码，直接打印 4
8.  任务队列又执行完了，又检查微任务队列，发现（8），打印 6
9.  任务队列又执行完了，检查微任务队列，没有任务，再检查宏任务队列，此时如果超过了50ms的话，会发现 console.log(8) 在宏任务队列中，于是执行 打印 8
10.  依次打印 1 2

*顺便一提，Promise初始化的函数会直接执行，是在同步任务里的*
# 异步的标准答案
JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中， 而渲染主线程只有一个。
而渲染主线程承担着诸多工作，渲染页面、执行js都在其中运行。
如果使用同步方式，极有可能导致主线程产生阻塞，从而导致消息队列中 很多其他任务无法得到执行。
所以浏览器采用异步的方式来避免。具体是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。
在这种异步模式下，浏览器永不阻塞，从而最大限度保证了单线程的流畅运行。