<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="某不愿透露姓名的呆菇子"><meta name="copyright" content="某不愿透露姓名的呆菇子"><meta name="generator" content="Hexo 6.3.0"><meta name="theme" content="hexo-theme-yun"><title>力扣 | Hexo</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"sakuya-minagami.github.io","root":"/","title":"呆菇子的小窝","version":"1.10.6","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-1LL0D86CY9"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1LL0D86CY9');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="数组中心索引123456789var pivotIndex &#x3D; function (nums) &amp;#123;    let sum &#x3D; 0, left &#x3D; 0    nums.forEach(num &#x3D;&gt; sum +&#x3D; num) &#x2F;&#x2F;先求和    for(let i &#x3D; 0; i &lt; nums.length; i++) &amp;#123;        if(i &gt; 0) left +">
<meta property="og:type" content="article">
<meta property="og:title" content="力扣">
<meta property="og:url" content="http://sakuya-minagami.github.io/2023/08/31/%E5%8A%9B%E6%89%A3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数组中心索引123456789var pivotIndex &#x3D; function (nums) &amp;#123;    let sum &#x3D; 0, left &#x3D; 0    nums.forEach(num &#x3D;&gt; sum +&#x3D; num) &#x2F;&#x2F;先求和    for(let i &#x3D; 0; i &lt; nums.length; i++) &amp;#123;        if(i &gt; 0) left +">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-31T08:31:50.154Z">
<meta property="article:modified_time" content="2024-03-05T08:57:16.653Z">
<meta property="article:author" content="某不愿透露姓名的呆菇子">
<meta name="twitter:card" content="summary"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="某不愿透露姓名的呆菇子"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="某不愿透露姓名的呆菇子"><span class="site-author-status" title="Looking for dawn.">🌑</span></a><div class="site-author-name"><a href="/about/">某不愿透露姓名的呆菇子</a></div><span class="site-name">Hexo</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">103</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:clipboard-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a><a class="links-item hty-icon-button" href="/girls/" title="喜欢的女孩子" style="color:hotpink"><span class="icon iconify" data-icon="ri:women-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95"><span class="toc-number">1.</span> <span class="toc-text">数组中心索引</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">搜索插入位置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">合并两个有序数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9C%B0%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">4.</span> <span class="toc-text">原地移除元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">5.</span> <span class="toc-text">有效括号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">6.</span> <span class="toc-text">有序数组去重</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E8%82%A1%E7%A5%A8%E5%88%A9%E6%B6%A6%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">最大股票利润问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">8.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">爬楼梯问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC"><span class="toc-number">10.</span> <span class="toc-text">字符串反转</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">11.</span> <span class="toc-text">合并有序链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-number">12.</span> <span class="toc-text">字符串最长公共前缀</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">13.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF"><span class="toc-number">14.</span> <span class="toc-text">判断链表有环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-number">15.</span> <span class="toc-text">多数元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AC%E5%9C%88%E6%B8%B8%E6%88%8F"><span class="toc-number">16.</span> <span class="toc-text">转圈游戏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%88%E5%B9%B6"><span class="toc-number">17.</span> <span class="toc-text">二叉树合并</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">18.</span> <span class="toc-text">二叉树中序遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE"><span class="toc-number">19.</span> <span class="toc-text">整数的各位积和之差</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%9A%E5%9F%8E%E5%A0%A1%E6%95%B0"><span class="toc-number">20.</span> <span class="toc-text">最多城堡数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%80%E9%AA%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%B9%E7%A7%B0"><span class="toc-number">21.</span> <span class="toc-text">检验二叉树对称</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9"><span class="toc-number">22.</span> <span class="toc-text">删除指定节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">23.</span> <span class="toc-text">交换二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-number">24.</span> <span class="toc-text">相交链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">25.</span> <span class="toc-text">回文字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">26.</span> <span class="toc-text">回文链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98"><span class="toc-number">27.</span> <span class="toc-text">种花问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">28.</span> <span class="toc-text">异位词</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">29.</span> <span class="toc-text">二叉树路径总和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">30.</span> <span class="toc-text">二叉树最小深度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">31.</span> <span class="toc-text">有序数组的平方</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E6%95%B0"><span class="toc-number">32.</span> <span class="toc-text">寻找只出现一次数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C"><span class="toc-number">33.</span> <span class="toc-text">二进制求和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-number">34.</span> <span class="toc-text">杨辉三角</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%8C%E6%9E%84"><span class="toc-number">35.</span> <span class="toc-text">字符串同构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02"><span class="toc-number">36.</span> <span class="toc-text">寻找重复元素2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">37.</span> <span class="toc-text">队列实现栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">38.</span> <span class="toc-text">二叉树所有路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0"><span class="toc-number">39.</span> <span class="toc-text">各位相加</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC"><span class="toc-number">40.</span> <span class="toc-text">第一个错误版本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%93%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%88%86%E6%B3%95%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6"><span class="toc-number">40.1.</span> <span class="toc-text">专题：二分法边界条件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B"><span class="toc-number">41.</span> <span class="toc-text">单词规律</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%BA%A4%E9%9B%86"><span class="toc-number">42.</span> <span class="toc-text">两数交集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6"><span class="toc-number">43.</span> <span class="toc-text">字符串中第一个唯一字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">44.</span> <span class="toc-text">盛最多水的容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">45.</span> <span class="toc-text">四数之和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0"><span class="toc-number">46.</span> <span class="toc-text">组合总数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">47.</span> <span class="toc-text">跳跃游戏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">48.</span> <span class="toc-text">全排列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pow%EF%BC%88x%EF%BC%8Cn%EF%BC%89"><span class="toc-number">49.</span> <span class="toc-text">pow（x，n）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">50.</span> <span class="toc-text">最大子数组和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-1"><span class="toc-number">51.</span> <span class="toc-text">跳跃游戏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52"><span class="toc-number">52.</span> <span class="toc-text">螺旋矩阵2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842"><span class="toc-number">53.</span> <span class="toc-text">不同路径2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-number">54.</span> <span class="toc-text">子集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E9%83%A8%E5%BC%80%E8%8A%B1%E6%9C%80%E6%97%A9%E4%B8%80%E5%A4%A9"><span class="toc-number">55.</span> <span class="toc-text">全部开花最早一天</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2"><span class="toc-number">56.</span> <span class="toc-text">买卖股票最佳时机2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">56.1.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">56.2.</span> <span class="toc-text">贪心算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%92%8C%E6%9D%86"><span class="toc-number">57.</span> <span class="toc-text">环和杆</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://sakuya-minagami.github.io/2023/08/31/%E5%8A%9B%E6%89%A3/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="某不愿透露姓名的呆菇子"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">力扣<a class="post-edit-link" href="https://github.com/YunYouJun/yunyoujun.github.io/tree/hexo/source/_posts/力扣.md" target="_blank" title="编辑" rel="noopener"><span class="icon iconify" data-icon="ri:edit-line"></span></a></h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2023-08-31 16:31:50" itemprop="dateCreated datePublished" datetime="2023-08-31T16:31:50+08:00">2023-08-31</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2024-03-05 16:57:16" itemprop="dateModified" datetime="2024-03-05T16:57:16+08:00">2024-03-05</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="数组中心索引"><a href="#数组中心索引" class="headerlink" title="数组中心索引"></a>数组中心索引</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pivotIndex = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>, left = <span class="number">0</span></span><br><span class="line">    nums.<span class="title function_">forEach</span>(<span class="function"><span class="params">num</span> =&gt;</span> sum += num) <span class="comment">//先求和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>) left += nums[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span>(left * <span class="number">2</span> === sum - nums[i]) <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchInsert = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(target &gt; nums[nums.<span class="property">length</span>-<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="property">length</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= nums[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解答：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并调节，二分查找的修改</span></span><br><span class="line"><span class="keyword">var</span> searchInsert = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=m;i&lt;m+n;++i)&#123;</span><br><span class="line">        nums1[i] = nums2[i-m]</span><br><span class="line">    &#125;</span><br><span class="line">    nums1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span>a-b)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="原地移除元素"><a href="#原地移除元素" class="headerlink" title="原地移除元素"></a>原地移除元素</h1><p><strong>这就是双指针</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    nums.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(item !== val)&#123;</span><br><span class="line">            nums[index++] =item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    nums.<span class="property">length</span> = index</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h1><p>注意不一定先小括号后中括号再大括号<br>主要是replace太好用了，消消乐写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> len =s.<span class="property">length</span>;</span><br><span class="line">	<span class="keyword">if</span>(len % <span class="number">2</span> !==<span class="number">0</span> )&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">let</span> length = len / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">			s = s.<span class="title function_">replace</span>(<span class="string">&quot;()&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">			s = s.<span class="title function_">replace</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">			s = s.<span class="title function_">replace</span>(<span class="string">&quot;[]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主流是堆栈写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">const</span> start = s[i];</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="string">&#x27;(&#x27;</span> || start == <span class="string">&#x27;[&#x27;</span> || start == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(start);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> end = stack[stack.<span class="property">length</span>-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(start == <span class="string">&#x27;)&#x27;</span>&amp;&amp; end==<span class="string">&#x27;(&#x27;</span> ||</span><br><span class="line">                start == <span class="string">&#x27;&#125;&#x27;</span>&amp;&amp; end==<span class="string">&#x27;&#123;&#x27;</span> ||</span><br><span class="line">                start == <span class="string">&#x27;]&#x27;</span>&amp;&amp; end==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    stack.<span class="title function_">pop</span>()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="有序数组去重"><a href="#有序数组去重" class="headerlink" title="有序数组去重"></a>有序数组去重</h1><p>没参考答案写出来的双指针，可喜可贺</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ref = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] !== nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">            nums[ref++] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ref</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="最大股票利润问题"><a href="#最大股票利润问题" class="headerlink" title="最大股票利润问题"></a>最大股票利润问题</h1><p>也就是动态规划问题，是一个新的方向<br>核心思想是将每一天的利润转化为前一天的和今天的比较<br>遍历在每一天出售的情况，利润要么是前一天已知的最大利润，要么是当日售价减去过去最小买价</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> buy = <span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="keyword">let</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> price <span class="keyword">of</span> prices) &#123;</span><br><span class="line">        buy = <span class="title class_">Math</span>.<span class="title function_">min</span>(buy, price);<span class="comment">//找最小买入值</span></span><br><span class="line">        profit = <span class="title class_">Math</span>.<span class="title function_">max</span>(profit, price - buy);<span class="comment">//更新最大利润值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>本题仅限一次买入卖出，之后还有更复杂的情形，比如多次，比如手续费</em></p>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>看过思路后自己写，值得祝贺<br><em>奇妙的双指针</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cur = head;</span><br><span class="line">    <span class="keyword">var</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> temp = head;</span><br><span class="line">    <span class="keyword">while</span>(cur !== <span class="literal">null</span>)&#123;</span><br><span class="line">        temp = cur.<span class="property">next</span>;<span class="comment">// 保存下一个节点</span></span><br><span class="line">        cur.<span class="property">next</span> = pre;<span class="comment">// 节点回指</span></span><br><span class="line">        pre = cur;<span class="comment">// 右移双指针</span></span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h1><p>显然的递归，但是直接套函数会超时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f(n)&#123;</span><br><span class="line">	return f(n-1) + f(n-2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解答给的直接求数列方法很好</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> a2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> a3 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        a1 = a2;</span><br><span class="line">        a2 = a3;</span><br><span class="line">        a3 = a1 + a2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h1><p>这个面试考过，秒了很爽<br>主要是用上了解构的办法，交换很清晰</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseString = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>/<span class="number">2</span>;++i)&#123;</span><br><span class="line">        [s[i],s[len-<span class="number">1</span>-i]] = [s[len-<span class="number">1</span>-i],s[i]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h1><p>还是很难想到这个递归</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="keyword">function</span>(<span class="params">list1, list2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(list1 === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list2</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2 === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list1</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.<span class="property">val</span> &gt;list2.<span class="property">val</span>)&#123;</span><br><span class="line">            list2.<span class="property">next</span> = <span class="title function_">mergeTwoLists</span>(list1,list2.<span class="property">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            list1.<span class="property">next</span> = <span class="title function_">mergeTwoLists</span>(list2,list1.<span class="property">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="字符串最长公共前缀"><a href="#字符串最长公共前缀" class="headerlink" title="字符串最长公共前缀"></a>字符串最长公共前缀</h1><p>其实是一个怎么考虑遍历的问题，注意细节</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="keyword">function</span>(<span class="params">strs</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ref = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> len = ref.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;strs.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!strs[j].<span class="title function_">charAt</span>(i) || strs[j][i] !== ref[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> ans.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)<span class="comment">// 数组转字符串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="title function_">push</span>(ref[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)<span class="comment">// 数组转字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>其实这个比二分插入简单的多，但还是边界问题<br>left&lt;&#x3D;right很重要</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> right = nums.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] === target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">            right = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="判断链表有环"><a href="#判断链表有环" class="headerlink" title="判断链表有环"></a>判断链表有环</h1><p>其实已经知道是快慢指针，但是不清楚边界条件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(head === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> fast = head.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">var</span> slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(slow.<span class="property">next</span> === fast.<span class="property">next</span>.<span class="property">next</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h1><p>找到数组中超过一半的元素并输出<br>最简单是排序，一半处的数即为最多的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span>/<span class="number">2</span>)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>称为摩尔投票法，其实也是动态规划，从前n-1个数与第n个数比较</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ref = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] !== ref)&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            ref = nums[i];</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ref</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="转圈游戏"><a href="#转圈游戏" class="headerlink" title="转圈游戏"></a>转圈游戏</h1><p>其实思路很简单，就是可能会莫名卡住</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> circularGameLosers = <span class="keyword">function</span>(<span class="params">n, k</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> arr = [];</span><br><span class="line">   <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">var</span> times = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">       arr.<span class="title function_">push</span>(i)</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">while</span>(arr[index]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">       arr[index] *= -<span class="number">1</span>;</span><br><span class="line">       index = (index + times * k ) % n;</span><br><span class="line">       times++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树合并"><a href="#二叉树合并" class="headerlink" title="二叉树合并"></a>二叉树合并</h1><p>二叉树也忘光了，算是康复训练<br>主要还是递归</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTrees = <span class="keyword">function</span>(<span class="params">root1, root2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root1 === <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">    <span class="keyword">if</span>(root2 === <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.<span class="property">val</span> + root2.<span class="property">val</span>,</span><br><span class="line">    <span class="title function_">mergeTrees</span>(root1.<span class="property">left</span>,root2.<span class="property">left</span>),</span><br><span class="line">    <span class="title function_">mergeTrees</span>(root1.<span class="property">right</span>,root2.<span class="property">right</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h1><p>本来想在函数本身递归的，但是注意到ans会在递归中重置<br>需要新开函数inorder，本身不返回值但会按顺序push入栈<br>换句话说，inorder函数是遍历顺序的体现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="title function_">inorder</span>(root.<span class="property">left</span>);</span><br><span class="line">        ans.<span class="title function_">push</span>(root.<span class="property">val</span>);</span><br><span class="line">        <span class="title function_">inorder</span>(root.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inorder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="整数的各位积和之差"><a href="#整数的各位积和之差" class="headerlink" title="整数的各位积和之差"></a>整数的各位积和之差</h1><p>想到用字符串直接拆解，不过要记得转回数字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subtractProductAndSum = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> mul = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> str = n.<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.<span class="property">length</span>;++i)&#123;</span><br><span class="line">        sum += <span class="built_in">parseInt</span>(str[i]);</span><br><span class="line">        mul *= <span class="built_in">parseInt</span>(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mul - sum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="最多城堡数"><a href="#最多城堡数" class="headerlink" title="最多城堡数"></a>最多城堡数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> captureForts = <span class="keyword">function</span>(<span class="params">forts</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>, pre = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; forts.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (forts[i] == <span class="number">1</span> || forts[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre &gt;= <span class="number">0</span> &amp;&amp; forts[i] != forts[pre]) &#123;</span><br><span class="line">                ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(ans, i - pre - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pre = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="检验二叉树对称"><a href="#检验二叉树对称" class="headerlink" title="检验二叉树对称"></a>检验二叉树对称</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">p,q</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p === <span class="literal">null</span> &amp;&amp; q === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p === <span class="literal">null</span> || q === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.<span class="property">val</span> !== q.<span class="property">val</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">f</span>(p.<span class="property">left</span>,q.<span class="property">right</span>) &amp;&amp; <span class="title function_">f</span>(p.<span class="property">right</span>,q.<span class="property">left</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>(root.<span class="property">left</span>,root.<span class="property">right</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="删除指定节点"><a href="#删除指定节点" class="headerlink" title="删除指定节点"></a>删除指定节点</h1><p>主要是设置一个虚拟头节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> pre = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">var</span> cur = pre;</span><br><span class="line">    <span class="comment">// 注意 一定要设置条件为cur.next否则访问不到报错</span></span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span> !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">next</span>.<span class="property">val</span> === val)&#123;</span><br><span class="line">            cur.<span class="property">next</span> =  cur.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="交换二叉树"><a href="#交换二叉树" class="headerlink" title="交换二叉树"></a>交换二叉树</h1><p>没想到会是声明赋值出错，注释的写法会影响后续的递归</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> invertTree = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// root.left = invertTree(root.right);</span></span><br><span class="line">    <span class="comment">// root.right = invertTree(root.left);</span></span><br><span class="line">    <span class="keyword">const</span> left = <span class="title function_">invertTree</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">const</span> right = <span class="title function_">invertTree</span>(root.<span class="property">right</span>);</span><br><span class="line">    root.<span class="property">left</span> = right;</span><br><span class="line">    root.<span class="property">right</span> = left;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><p>主要是最终双指针一定能同时为null跳出循环没想到</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = headA;</span><br><span class="line">    <span class="keyword">var</span> q = headB;</span><br><span class="line">    <span class="keyword">if</span>(headA === <span class="literal">null</span> || headB === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(p !== q)&#123;</span><br><span class="line">        p = p === <span class="literal">null</span> ? headB : p.<span class="property">next</span>;</span><br><span class="line">        q = q === <span class="literal">null</span> ? headA : q.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h1><p>正则匹配还是用不惯</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    s=s.<span class="title function_">replace</span>(<span class="regexp">/[^a-zA-Z0-9]/g</span>,<span class="string">&quot;&quot;</span>).<span class="title function_">replace</span>(<span class="regexp">/\s/g</span>,<span class="string">&quot;&quot;</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">     <span class="keyword">return</span> s===[...s].<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><p>注意数组不能使用&#x3D;&#x3D;&#x3D; 判断，会认定为object为true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">while</span>(p !== <span class="literal">null</span>)&#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(p.<span class="property">val</span>);</span><br><span class="line">        p = p.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) === arr.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="种花问题"><a href="#种花问题" class="headerlink" title="种花问题"></a>种花问题</h1><p>关键：通过补0避免讨论边界条件<br>以及直接对原数组修改，符合条件直接种花</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canPlaceFlowers = <span class="keyword">function</span>(<span class="params">flowerbed, n</span>) &#123;</span><br><span class="line">    flowerbed.<span class="title function_">unshift</span>(<span class="number">0</span>);</span><br><span class="line">    flowerbed.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;flowerbed.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flowerbed[i-<span class="number">1</span>] === <span class="number">0</span> &amp;&amp; flowerbed[i] === <span class="number">0</span> &amp;&amp; flowerbed[i+<span class="number">1</span>] === <span class="number">0</span>)&#123;</span><br><span class="line">            flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt;= n</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="异位词"><a href="#异位词" class="headerlink" title="异位词"></a>异位词</h1><p>排序法最轻松，主要是写一下哈希法<br>创建表，表元素为<code>[&#39;a&#39;,1]</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();   </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> s) &#123;      </span><br><span class="line">         <span class="keyword">if</span> (map.<span class="title function_">has</span>(n)) &#123;</span><br><span class="line">             map.<span class="title function_">set</span>(n, map.<span class="title function_">get</span>(n) + <span class="number">1</span>); </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             map.<span class="title function_">set</span>(n, <span class="number">1</span>);         </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>遍历t</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> t) &#123;            </span><br><span class="line">         <span class="keyword">if</span> (map.<span class="title function_">has</span>(n) &amp;&amp; map.<span class="title function_">get</span>(n) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">               map.<span class="title function_">set</span>(n, map.<span class="title function_">get</span>(n) - <span class="number">1</span>);   </span><br><span class="line">               <span class="comment">//每找到一个，键值-1；</span></span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;                     </span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//循环结束后为s与t异位,必定t中的元素在s的map中都能找到</span></span><br></pre></td></tr></table></figure>
<p>应该没办法直接比较s和t的表，所以退一步，依次比较到最后的视为匹配</p>
<h1 id="二叉树路径总和"><a href="#二叉树路径总和" class="headerlink" title="二叉树路径总和"></a>二叉树路径总和</h1><p>第一时间想到的是递归，注意边界条件，确定初始节点为空和到达叶子结点的条件，以及全程的返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="keyword">function</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; root.<span class="property">right</span> === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root.<span class="property">val</span> === targetSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">hasPathSum</span>(root.<span class="property">left</span>,targetSum-root.<span class="property">val</span>) || <span class="title function_">hasPathSum</span>(root.<span class="property">right</span>,targetSum-root.<span class="property">val</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h1><p>同样是边界条件没做好，忽略了没有子树的情况，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; root.<span class="property">right</span> === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            ans = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title function_">minDepth</span>(root.<span class="property">left</span>), ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            ans = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title function_">minDepth</span>(root.<span class="property">right</span>), ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1><p>输入递增输出也递增，排序法不写了<br>主要是双指针法，很新奇，时间复杂度为O(n)<br>思路是大值在两端，小值在中间，用双指针从两边遍历</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = nums.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> ans = [];</span><br><span class="line">    <span class="keyword">let</span> index = nums.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] * nums[i] &gt;= nums[j] * nums[j])&#123;</span><br><span class="line">            ans[index] = nums[i] * nums[i];</span><br><span class="line">            index--;</span><br><span class="line">            i++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[index] = nums[j] * nums[j];</span><br><span class="line">            index--;</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="寻找只出现一次数"><a href="#寻找只出现一次数" class="headerlink" title="寻找只出现一次数"></a>寻找只出现一次数</h1><p>主要是异或思路</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    nums.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        ans = item ^ ans;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h1><p>主要是会溢出，不然转十进制很简单<br>关键点是补零和进位的考虑<br>这里一个比较好的思路是初始化flag&#x3D;0，每次循环最后更新进位数flag，最后讨论是否需要进位增1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addBinary = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxlen = <span class="title class_">Math</span>.<span class="title function_">max</span>(a.<span class="property">length</span>,b.<span class="property">length</span>);</span><br><span class="line">    a = a.<span class="title function_">padStart</span>(maxlen, <span class="number">0</span>);</span><br><span class="line">    b = b.<span class="title function_">padStart</span>(maxlen, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> ans = [];</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=maxlen-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = <span class="built_in">parseInt</span>(a[i]) + <span class="built_in">parseInt</span>(b[i]) + flag;</span><br><span class="line">        <span class="keyword">if</span>(c &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            ans[i] = c-<span class="number">2</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[i] = c;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        ans.<span class="title function_">unshift</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h1><p>一个致命的问题：当返回的是双层数组的时候，返回值不能采用构造法，而必须采用赋值法<br>因为直接传入的数组是引用值，会随时被后续修改，要用就必须替换掉</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generate = <span class="keyword">function</span>(<span class="params">numRows</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = [[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">let</span> row = [<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;numRows-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = <span class="keyword">new</span> <span class="title class_">Array</span>(...row);<span class="comment">// 创建新数组，跟row独立</span></span><br><span class="line">        <span class="keyword">if</span>(i === <span class="number">0</span>)&#123;</span><br><span class="line">            temp = [<span class="number">1</span>];<span class="comment">// new Array语法只传一个数字会表示新数组长度，这里重新修改temp</span></span><br><span class="line">        &#125;</span><br><span class="line">        temp.<span class="title function_">push</span>(<span class="number">0</span>)<span class="comment">// 右添0错开</span></span><br><span class="line">        row.<span class="title function_">unshift</span>(<span class="number">0</span>);<span class="comment">// 左添0错开</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;row.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            row[j] += temp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="title function_">push</span>([...row]);<span class="comment">// es6标准，展开运算符，保证push的是新创建的数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="字符串同构"><a href="#字符串同构" class="headerlink" title="字符串同构"></a>字符串同构</h1><p>哈希表还是不熟</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isIsomorphic = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> s2t = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> t2s = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> len = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = s[i], y = t[i];</span><br><span class="line">        <span class="keyword">if</span> ((s2t[x] &amp;&amp; s2t[x] !== y) || (t2s[y] &amp;&amp; t2s[y] !== x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s2t[x] = y;</span><br><span class="line">        t2s[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="寻找重复元素2"><a href="#寻找重复元素2" class="headerlink" title="寻找重复元素2"></a>寻找重复元素2</h1><p>非常简洁的map使用，最精彩的是在不断向右遍历的过程中，要寻找最小的距离，就要每次重复都更新i值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> containsNearbyDuplicate = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(nums[i]) &amp;&amp; i - map.<span class="title function_">get</span>(nums[i]) &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h1><p>有些复杂</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_queue</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>());<span class="comment">// queue末尾接到_queue前端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="title function_">shift</span>());<span class="comment">// _queue末尾接到queue前端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">slice</span>(-<span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="二叉树所有路径"><a href="#二叉树所有路径" class="headerlink" title="二叉树所有路径"></a>二叉树所有路径</h1><p>主要是想清楚在什么地方递归，箭号的位置在哪<br>递归的边界依然是叶节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> paths = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">construct_paths</span> = (<span class="params">root, path</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            path += root.<span class="property">val</span>.<span class="title function_">toString</span>();</span><br><span class="line">            <span class="keyword">if</span> (root.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; root.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">                paths.<span class="title function_">push</span>(path);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">                <span class="title function_">construct_paths</span>(root.<span class="property">left</span>, path);</span><br><span class="line">                <span class="title function_">construct_paths</span>(root.<span class="property">right</span>, path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">construct_paths</span>(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="各位相加"><a href="#各位相加" class="headerlink" title="各位相加"></a>各位相加</h1><p>即数字根问题<br>一定要注意为什么是<code>(sum -1 ) % 9 + 1</code>，其范围从1到9<br>sum%9范围从0到8</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addDigits = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> str = num.<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        sum += <span class="built_in">parseInt</span>(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sum -<span class="number">1</span> ) % <span class="number">9</span> + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="第一个错误版本"><a href="#第一个错误版本" class="headerlink" title="第一个错误版本"></a>第一个错误版本</h1><p>先存一下没写完的思路</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> solution = <span class="keyword">function</span>(<span class="params">isBadVersion</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">integer</span>&#125; n Total versions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">integer</span>&#125; The first bad version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(n &gt; m*(m+<span class="number">1</span>)/<span class="number">2</span>)&#123;</span><br><span class="line">           m++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">let</span> later = n;</span><br><span class="line">       <span class="keyword">let</span> early = n - m;</span><br><span class="line">       <span class="keyword">let</span> flag = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">           <span class="keyword">if</span>(early &lt; <span class="number">1</span>) early = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(<span class="title function_">isBadVersion</span>(early))&#123;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>正常还是用二分法<br><strong>一定要注意区间条件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> solution = <span class="keyword">function</span>(<span class="params">isBadVersion</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">integer</span>&#125; n Total versions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">integer</span>&#125; The first bad version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">       <span class="keyword">var</span> early = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">var</span> later = n;</span><br><span class="line">       <span class="keyword">while</span>(early &lt; later)&#123;</span><br><span class="line">           <span class="keyword">var</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((later - early)/<span class="number">2</span> + early);</span><br><span class="line">           <span class="keyword">if</span>(<span class="title function_">isBadVersion</span>(mid))&#123;</span><br><span class="line">               later = mid;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               early = mid + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> later</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="专题：二分法边界条件"><a href="#专题：二分法边界条件" class="headerlink" title="专题：二分法边界条件"></a>专题：二分法边界条件</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchInsert = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> right = nums.<span class="property">length</span></span><br><span class="line">  <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; target) &#123; <span class="keyword">return</span> <span class="number">0</span>&#125;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(left + (right - left)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">      left = mid + <span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">      right = mid</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> right = nums.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(left + (right - left)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">      left = mid + <span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">      right = mid</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>区间：<code>[left,right)</code>，由<code>while(left &lt; right)</code>决定<br>因为可搜索时left和right一定不等<br>重置区间：<code>left = mid + 1</code>，由区间决定<br>保证每次都一定会缩小区间，同理<code>right = mid</code><br>返回：left，由区间决定，因为left一定是最满足的</p>
<h1 id="单词规律"><a href="#单词规律" class="headerlink" title="单词规律"></a>单词规律</h1><p>同样是字符串同构匹配，使用哈希表<br>关键在映射条件的判定</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wordPattern = <span class="keyword">function</span>(<span class="params">pattern, s</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> pre = <span class="number">0</span>;</span><br><span class="line">    arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] === <span class="string">&quot; &quot;</span>)&#123;</span><br><span class="line">            arr.<span class="title function_">push</span>(s.<span class="title function_">slice</span>(pre,i));</span><br><span class="line">            pre = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="title function_">push</span>(s.<span class="title function_">slice</span>(pre,s.<span class="property">length</span>));</span><br><span class="line">    <span class="comment">// 注意数组不等长是可能判定同构的 这里要求映射和数量都要相等</span></span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> !== pattern.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;pattern.<span class="property">length</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">const</span> x = pattern[j];</span><br><span class="line">        <span class="keyword">const</span> y = arr[j];</span><br><span class="line">        <span class="keyword">if</span>((map1.<span class="title function_">has</span>(x) &amp;&amp; map1.<span class="title function_">get</span>(x) !== y) || (map2.<span class="title function_">has</span>(y) &amp;&amp; map2.<span class="title function_">get</span>(y) !== x))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            map1.<span class="title function_">set</span>(x,y);</span><br><span class="line">            map2.<span class="title function_">set</span>(y,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="两数交集"><a href="#两数交集" class="headerlink" title="两数交集"></a>两数交集</h1><p>注意两个数组地位相同，排序以后是不清楚谁的初始下标更小的<br>所以不能遍历其中一个坐标，而是两个坐标动态移动</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intersect = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    nums1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">    nums2.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = <span class="number">0</span>, ans = [];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; nums1.<span class="property">length</span> &amp;&amp; r &lt; nums2.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[l] === nums2[r]) &#123;</span><br><span class="line">            ans.<span class="title function_">push</span>(nums1[l]);</span><br><span class="line">            l++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125; <span class="keyword">else</span> nums1[l] &lt; nums2[r] ? l++ : r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="字符串中第一个唯一字符"><a href="#字符串中第一个唯一字符" class="headerlink" title="字符串中第一个唯一字符"></a>字符串中第一个唯一字符</h1><p>用同下标法确实最简单</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) </span><br><span class="line">        <span class="keyword">if</span> (s.<span class="title function_">indexOf</span>(s[i]) === s.<span class="title function_">lastIndexOf</span>(s[i]))</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>哈希法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> i = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (++i &lt; s.<span class="property">length</span>)&#123;</span><br><span class="line">        map.<span class="title function_">set</span>(s[i], map.<span class="title function_">has</span>(s[i]) ? -<span class="number">1</span> : i);</span><br><span class="line">    &#125;</span><br><span class="line">    i = -<span class="number">1</span>;</span><br><span class="line">    map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, _, map</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(item !== -<span class="number">1</span>)&#123;</span><br><span class="line">            i = item; </span><br><span class="line">            map.<span class="title function_">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h1><p>本来以为是动态规划的题，但是可以进一步简化思路<br>采用双指针，因为规划量<code>S = (j-i)*min(height[i],height[j])</code>中，j-i可以通过双指针相互逼近，保证已经提前取到最大的j-i<br>还有一个重点，双指针移动先移动矮柱子，因为移动高柱子一定对规划量是负贡献</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = height.<span class="property">length</span> - <span class="number">1</span>; i &lt; j; ) &#123;</span><br><span class="line">        res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, <span class="title class_">Math</span>.<span class="title function_">min</span>(height[i], height[j]) * (j - i))</span><br><span class="line">        height[i] &lt; height[j] ? i++ : j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h1><p>主要是关于自己思路的错误<br>一方面是把continue和break忘得差不多了<br>continue是跳过下面代码进入下层循环，break则是直接终止循环<br>之前没写break导致双指针left和right一直在while里没动出不去<br>但是我采用了i左j右的遍历形式，从两边逼近</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fourSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(nums)</span><br><span class="line">    <span class="keyword">var</span> ans = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=nums.<span class="property">length</span>-<span class="number">1</span>;j-<span class="number">2</span>&gt;i;j--)&#123;</span><br><span class="line">            <span class="keyword">var</span> left = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">var</span> right = j-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">const</span> sum = nums[i]+nums[j]+nums[left]+nums[right];</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(left,right)</span><br><span class="line">                <span class="keyword">if</span>(sum === target)&#123;</span><br><span class="line">                    ans.<span class="title function_">push</span>([nums[i],nums[j],nums[left],nums[right]]);</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">// 很重要</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    sum &lt; target ? left++ : right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="组合总数"><a href="#组合总数" class="headerlink" title="组合总数"></a>组合总数</h1><p>同样是dfs，想到这个迭代规则不容易，要确定边界更不容易<br>确定一个二叉树，节点输入已经选用的数字池pool，目标target，当前参考下标index<br>左树搜索池子pool不改变，index右移的可能<br>右树搜索参考值入池，index不变的可能<br>该过程会遍历所有可能target<br>边界条件为target为0，收入答案；或者下标越界，<code>index === candidates.length</code><br>其实看懂不难，但是思路清晰很难，一开始无论如何都收敛不到边界然后爆栈</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum = <span class="keyword">function</span>(<span class="params">candidates, target</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ans = [];</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">pool,target,index</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index === candidates.<span class="property">length</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target === <span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="title function_">push</span>(pool);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">dfs</span>([...pool],target,index+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= candidates[index])&#123;</span><br><span class="line">            <span class="title function_">dfs</span>([...pool,candidates[index]],target-candidates[index],index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>([],target,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h1><p>难得自己想出来，结果时间空间都糟糕，啊哈哈<br>不过自己的想法也有点看头，用动态规划的考虑，构造次数数组，每次考虑次数都从之前写在该处的次数开始（因为每个地方一定跳得到，所以之前一定会在这个地方赋值time）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jump = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> times = [<span class="number">0</span>,];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">write</span> = (<span class="params">i, time</span>) =&gt; &#123;</span><br><span class="line">        time++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= nums[i]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!times[i + j]) &#123;</span><br><span class="line">                times[i + j] = time;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">write</span>(i,times[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> times[nums.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用贪心算法最好，到达最后一格的一定是从左边最近的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jump = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = nums.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> left = <span class="number">0</span>;left &lt; index;left++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] + left &gt;= index)&#123;</span><br><span class="line">                index = left;</span><br><span class="line">                step++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关键是index从右边开始找最近路线，left从左边找最远距离</p>
<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>自己写的，干净又整洁，时间空间都高</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">to</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(to.<span class="property">length</span> === nums.<span class="property">length</span>)&#123;</span><br><span class="line">            ans.<span class="title function_">push</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!to.<span class="title function_">includes</span>(nums[i]))&#123;</span><br><span class="line">                <span class="title function_">dfs</span>([...to,nums[i]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>([]);</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="pow（x，n）"><a href="#pow（x，n）" class="headerlink" title="pow（x，n）"></a>pow（x，n）</h1><p>用循环会超时，分治法复杂度为logn</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myPow = <span class="keyword">function</span>(<span class="params">x, n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>/<span class="title function_">myPow</span>(x,-n);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">myPow</span>(x * x,n/<span class="number">2</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * <span class="title function_">myPow</span>(x,n-<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h1><p>想清楚不容易，不过列出动态规划转移方程就好了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> pre = <span class="number">0</span>;</span><br><span class="line">    nums.<span class="title function_">forEach</span>( <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        pre = <span class="title class_">Math</span>.<span class="title function_">max</span>(pre + item,item);<span class="comment">// 每次都会扫描当前索引下最长子串</span></span><br><span class="line">        sum = <span class="title class_">Math</span>.<span class="title function_">max</span>(sum,pre);<span class="comment">// 所有记录过的最长串比较</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="跳跃游戏-1"><a href="#跳跃游戏-1" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h1><p>自己想的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canJump = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> ans = <span class="literal">true</span>;</span><br><span class="line">    nums.<span class="title function_">forEach</span>( <span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; index)&#123;</span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            max = <span class="title class_">Math</span>.<span class="title function_">max</span>(index + item,max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>别人给的思路，反向查找，很清晰并且复杂度很低</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canJump = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> end = nums.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=nums.<span class="property">length</span>-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] + i &gt;= end)&#123;</span><br><span class="line">            end = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end === <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="螺旋矩阵2"><a href="#螺旋矩阵2" class="headerlink" title="螺旋矩阵2"></a>螺旋矩阵2</h1><p>一如既往的复杂度糟糕，不过我觉得思路还挺清晰</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>( <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">    <span class="keyword">const</span> dir = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">var</span> dir_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> max = n*n;</span><br><span class="line">    <span class="keyword">while</span>(num &lt;= max)&#123;</span><br><span class="line">	    <span class="comment">// 每轮修改整行或列数字，碰到边界或者数已填充停止</span></span><br><span class="line">        <span class="keyword">while</span>(x &gt;=<span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; arr[x][y] === <span class="number">0</span>)&#123;</span><br><span class="line">            arr[x][y] = num;</span><br><span class="line">            x = x + dir[dir_index][<span class="number">0</span>];</span><br><span class="line">            y = y + dir[dir_index][<span class="number">1</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        x = x - dir[dir_index][<span class="number">0</span>];</span><br><span class="line">        y = y - dir[dir_index][<span class="number">1</span>];</span><br><span class="line">        dir_index++;</span><br><span class="line">        <span class="keyword">if</span>(dir_index === <span class="number">4</span>) dir_index = <span class="number">0</span>;</span><br><span class="line">        x = x + dir[dir_index][<span class="number">0</span>];</span><br><span class="line">        y = y + dir[dir_index][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="不同路径2"><a href="#不同路径2" class="headerlink" title="不同路径2"></a>不同路径2</h1><p>复杂度还可以，动态规划的训练，讲一下自己觉得巧妙的地方<br>1，设置<code>[m+1,n+1]</code>矩阵，用0填充，保证访问上和左时可以正常访问<br>2，对有障碍的地方直接设0，因为从上到下和从左到右遍历，所以不会出现设置障碍比计算路径晚的情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="keyword">function</span>(<span class="params">obstacleGrid</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = obstacleGrid.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> n = obstacleGrid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(m+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;m+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*j === <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i-<span class="number">1</span>][j-<span class="number">1</span>] === <span class="number">1</span>)&#123;</span><br><span class="line">                arr[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                arr[i][j] = arr[i-<span class="number">1</span>][j] + arr[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// console.log(arr,arr[i-1][j],arr[i][j-1],i,j)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[m][n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h1><p>服气了，这么简单想这么久<br>树形结构想到了，但是没分清是遍历过程push还是遍历结束push</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">var</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">pool,cur</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur === n)&#123;</span><br><span class="line">            ans.<span class="title function_">push</span>(pool);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">dfs</span>([...pool],cur+<span class="number">1</span>);</span><br><span class="line">        <span class="title function_">dfs</span>([...pool,nums[cur]],cur+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>([],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="全部开花最早一天"><a href="#全部开花最早一天" class="headerlink" title="全部开花最早一天"></a>全部开花最早一天</h1><p>困难题，没想到代码很简洁<br>主要是能不能理清题目<br>解析说的很清楚，解决是否交替播种问题，再解决谁先播种问题，剩下的就是动态规划的处理了<br>只考虑两颗种子<br>第一个问题，两颗种子种完的时间一定是固定的，开花时间由后一颗决定，但是前一颗可能因为交替种延后，所以不交替一定是最佳方案<br>第二个问题，只要最后一颗不是开花时间最短的（假设此时是总体开花时间最短的最优解），那么一定能跟最短的交换顺序，使得总体开花时间更短</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> earliestFullBloom = <span class="keyword">function</span>(<span class="params">plantTime, growTime</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;plantTime.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        arr.<span class="title function_">push</span>([plantTime[i],growTime[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b[<span class="number">1</span>]-a[<span class="number">1</span>]);</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        now +=item[<span class="number">0</span>];</span><br><span class="line">        ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(ans,now+item[<span class="number">1</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题解办法，提供了一种构造联合数组的办法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> earliestFullBloom = <span class="keyword">function</span> (<span class="params">plantTime, growTime</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>, days = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [p, g] <span class="keyword">of</span> _.<span class="title function_">zip</span>(plantTime, growTime).<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b[<span class="number">1</span>] - a[<span class="number">1</span>])) &#123;</span><br><span class="line">        days += p; <span class="comment">// 累加播种天数</span></span><br><span class="line">        ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(ans, days + g); <span class="comment">// 再加上生长天数，就是这个种子的开花时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="买卖股票最佳时机2"><a href="#买卖股票最佳时机2" class="headerlink" title="买卖股票最佳时机2"></a>买卖股票最佳时机2</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>这次就是充分的动态规划了，只不过动态转移方程确实有点不好想清楚<br>规划量为每天结束交易后手持股票和不手持股票的分别最大利润<br>不持股票时，最大利润为：前一天不持股票最大利润，与前一天持股票再抛出今天股票最大利润<br>手持股票时，最大利润为：前一天手持股票最大利润，与前一天不持股票再买入今天股票利润最大者<br>其实主要是后者比较容易纠结，出现负利润还该考虑吗？<br>应该换个角度，后者表示手上已有股票前提下，找到最节约的购买方式，其实也是变相找到了过去股票最低价</p>
<p>另外，不从动态规划的角度，还应该考虑这样问题：<br>在已知最小购入价时，我该在一个高价卖出，还是该等后续更高价呢？<br>我怎么知道是卖掉之后一次高价的钱多还是之后再低价买高价卖多呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(prices.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    arr[<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.<span class="property">length</span>;i++)&#123;</span><br><span class="line">       arr[<span class="number">0</span>][i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(arr[<span class="number">0</span>][i-<span class="number">1</span>],arr[<span class="number">1</span>][i-<span class="number">1</span>]+prices[i]);</span><br><span class="line">       arr[<span class="number">1</span>][i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(arr[<span class="number">1</span>][i-<span class="number">1</span>],arr[<span class="number">0</span>][i-<span class="number">1</span>]-prices[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>][prices.<span class="property">length</span>-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法的解法也很巧妙，将所有买入卖出看成一个区间，区间差即利润<br>更特别的是，将区间任意分解，利润可以任何作和叠加<br>因此我们的最大利润就是这些单位区间的筛选和，筛选条件为利润大于0<br>画成函数会更清楚，收集所有的上坡即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> n = prices.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans += <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="环和杆"><a href="#环和杆" class="headerlink" title="环和杆"></a>环和杆</h1><p>主要是能用数组维护就尽量用数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countPoints = <span class="keyword">function</span> (<span class="params">rings</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = rings.<span class="property">length</span> / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// var bars = new Array(10).fill(0).map(() =&gt; new Set());</span></span><br><span class="line">    <span class="keyword">var</span> bars = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> j = <span class="number">2</span> * i;</span><br><span class="line">        <span class="keyword">const</span> ring = rings[j];</span><br><span class="line">        <span class="keyword">const</span> bar = rings[j + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(ring === <span class="string">&#x27;R&#x27;</span>) bars[bar][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ring === <span class="string">&#x27;G&#x27;</span>) bars[bar][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ring === <span class="string">&#x27;B&#x27;</span>) bars[bar][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bars);</span><br><span class="line">    <span class="keyword">return</span> bars.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> !item.<span class="title function_">includes</span>(<span class="number">0</span>)).<span class="property">length</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>某不愿透露姓名的呆菇子</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://sakuya-minagami.github.io/2023/08/31/%E5%8A%9B%E6%89%A3/" title="力扣">http://sakuya-minagami.github.io/2023/08/31/%E5%8A%9B%E6%89%A3/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2023/09/04/Set%E4%B8%8EMap/" rel="prev" title="Set与Map"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">Set与Map</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2023/08/31/es6%E8%A7%84%E8%8C%83/" rel="next" title="es6规范"><span class="post-nav-text">es6规范</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2025 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> 某不愿透露姓名的呆菇子</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.6</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>